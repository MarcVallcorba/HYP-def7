{
  "version": 3,
  "sources": ["../../@supabase/gotrue-js/src/lib/helpers.ts", "../../@supabase/gotrue-js/src/lib/errors.ts", "../../@supabase/gotrue-js/src/lib/fetch.ts", "../../@supabase/gotrue-js/src/GoTrueAdminApi.ts", "../../@supabase/gotrue-js/src/lib/version.ts", "../../@supabase/gotrue-js/src/lib/constants.ts", "../../@supabase/gotrue-js/src/lib/local-storage.ts", "../../@supabase/gotrue-js/src/lib/polyfills.ts", "../../@supabase/gotrue-js/src/GoTrueClient.ts"],
  "sourcesContent": ["import { SupportedStorage } from './types'\r\nexport function expiresAt(expiresIn: number) {\r\n  const timeNow = Math.round(Date.now() / 1000)\r\n  return timeNow + expiresIn\r\n}\r\n\r\nexport function uuid() {\r\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\r\n    const r = (Math.random() * 16) | 0,\r\n      v = c == 'x' ? r : (r & 0x3) | 0x8\r\n    return v.toString(16)\r\n  })\r\n}\r\n\r\nexport const isBrowser = () => typeof document !== 'undefined'\r\n\r\nconst localStorageWriteTests = {\r\n  tested: false,\r\n  writable: false,\r\n}\r\n\r\n/**\r\n * Checks whether localStorage is supported on this browser.\r\n */\r\nexport const supportsLocalStorage = () => {\r\n  if (!isBrowser()) {\r\n    return false\r\n  }\r\n\r\n  try {\r\n    if (typeof globalThis.localStorage !== 'object') {\r\n      return false\r\n    }\r\n  } catch (e) {\r\n    // DOM exception when accessing `localStorage`\r\n    return false\r\n  }\r\n\r\n  if (localStorageWriteTests.tested) {\r\n    return localStorageWriteTests.writable\r\n  }\r\n\r\n  const randomKey = `lswt-${Math.random()}${Math.random()}`\r\n\r\n  try {\r\n    globalThis.localStorage.setItem(randomKey, randomKey)\r\n    globalThis.localStorage.removeItem(randomKey)\r\n\r\n    localStorageWriteTests.tested = true\r\n    localStorageWriteTests.writable = true\r\n  } catch (e) {\r\n    // localStorage can't be written to\r\n    // https://www.chromium.org/for-testers/bug-reporting-guidelines/uncaught-securityerror-failed-to-read-the-localstorage-property-from-window-access-is-denied-for-this-document\r\n\r\n    localStorageWriteTests.tested = true\r\n    localStorageWriteTests.writable = false\r\n  }\r\n\r\n  return localStorageWriteTests.writable\r\n}\r\n\r\nexport function getParameterByName(name: string, url?: string) {\r\n  if (!url) url = window?.location?.href || ''\r\n  // eslint-disable-next-line no-useless-escape\r\n  name = name.replace(/[\\[\\]]/g, '\\\\$&')\r\n  const regex = new RegExp('[?&#]' + name + '(=([^&#]*)|&|#|$)'),\r\n    results = regex.exec(url)\r\n  if (!results) return null\r\n  if (!results[2]) return ''\r\n  return decodeURIComponent(results[2].replace(/\\+/g, ' '))\r\n}\r\n\r\ntype Fetch = typeof fetch\r\n\r\nexport const resolveFetch = (customFetch?: Fetch): Fetch => {\r\n  let _fetch: Fetch\r\n  if (customFetch) {\r\n    _fetch = customFetch\r\n  } else if (typeof fetch === 'undefined') {\r\n    _fetch = async (...args) => await (await import('cross-fetch')).fetch(...args)\r\n  } else {\r\n    _fetch = fetch\r\n  }\r\n  return (...args) => _fetch(...args)\r\n}\r\n\r\nexport const looksLikeFetchResponse = (maybeResponse: unknown): maybeResponse is Response => {\r\n  return (\r\n    typeof maybeResponse === 'object' &&\r\n    maybeResponse !== null &&\r\n    'status' in maybeResponse &&\r\n    'ok' in maybeResponse &&\r\n    'json' in maybeResponse &&\r\n    typeof (maybeResponse as any).json === 'function'\r\n  )\r\n}\r\n\r\n// Storage helpers\r\nexport const setItemAsync = async (\r\n  storage: SupportedStorage,\r\n  key: string,\r\n  data: any\r\n): Promise<void> => {\r\n  await storage.setItem(key, JSON.stringify(data))\r\n}\r\n\r\nexport const getItemAsync = async (storage: SupportedStorage, key: string): Promise<unknown> => {\r\n  const value = await storage.getItem(key)\r\n\r\n  if (!value) {\r\n    return null\r\n  }\r\n\r\n  try {\r\n    return JSON.parse(value)\r\n  } catch {\r\n    return value\r\n  }\r\n}\r\n\r\nexport const removeItemAsync = async (storage: SupportedStorage, key: string): Promise<void> => {\r\n  await storage.removeItem(key)\r\n}\r\n\r\nexport function decodeBase64URL(value: string): string {\r\n  const key = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='\r\n  let base64 = ''\r\n  let chr1, chr2, chr3\r\n  let enc1, enc2, enc3, enc4\r\n  let i = 0\r\n  value = value.replace('-', '+').replace('_', '/')\r\n\r\n  while (i < value.length) {\r\n    enc1 = key.indexOf(value.charAt(i++))\r\n    enc2 = key.indexOf(value.charAt(i++))\r\n    enc3 = key.indexOf(value.charAt(i++))\r\n    enc4 = key.indexOf(value.charAt(i++))\r\n    chr1 = (enc1 << 2) | (enc2 >> 4)\r\n    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2)\r\n    chr3 = ((enc3 & 3) << 6) | enc4\r\n    base64 = base64 + String.fromCharCode(chr1)\r\n\r\n    if (enc3 != 64 && chr2 != 0) {\r\n      base64 = base64 + String.fromCharCode(chr2)\r\n    }\r\n    if (enc4 != 64 && chr3 != 0) {\r\n      base64 = base64 + String.fromCharCode(chr3)\r\n    }\r\n  }\r\n  return base64\r\n}\r\n\r\n/**\r\n * A deferred represents some asynchronous work that is not yet finished, which\r\n * may or may not culminate in a value.\r\n * Taken from: https://github.com/mike-north/types/blob/master/src/async.ts\r\n */\r\nexport class Deferred<T = any> {\r\n  public static promiseConstructor: PromiseConstructor = Promise\r\n\r\n  public readonly promise!: PromiseLike<T>\r\n\r\n  public readonly resolve!: (value?: T | PromiseLike<T>) => void\r\n\r\n  public readonly reject!: (reason?: any) => any\r\n\r\n  public constructor() {\r\n    // eslint-disable-next-line @typescript-eslint/no-extra-semi\r\n    ;(this as any).promise = new Deferred.promiseConstructor((res, rej) => {\r\n      // eslint-disable-next-line @typescript-eslint/no-extra-semi\r\n      ;(this as any).resolve = res\r\n      // eslint-disable-next-line @typescript-eslint/no-extra-semi\r\n      ;(this as any).reject = rej\r\n    })\r\n  }\r\n}\r\n\r\n// Taken from: https://stackoverflow.com/questions/38552003/how-to-decode-jwt-token-in-javascript-without-using-a-library\r\nexport function decodeJWTPayload(token: string) {\r\n  // Regex checks for base64url format\r\n  const base64UrlRegex = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}=?$|[a-z0-9_-]{2}(==)?$)$/i\r\n\r\n  const parts = token.split('.')\r\n\r\n  if (parts.length !== 3) {\r\n    throw new Error('JWT is not valid: not a JWT structure')\r\n  }\r\n\r\n  if (!base64UrlRegex.test(parts[1])) {\r\n    throw new Error('JWT is not valid: payload is not in base64url format')\r\n  }\r\n\r\n  const base64Url = parts[1]\r\n  return JSON.parse(decodeBase64URL(base64Url))\r\n}\r\n\r\n/**\r\n * Creates a promise that resolves to null after some time.\r\n */\r\nexport function sleep(time: number): Promise<null> {\r\n  return new Promise((accept) => {\r\n    setTimeout(() => accept(null), time)\r\n  })\r\n}\r\n\r\n/**\r\n * Converts the provided async function into a retryable function. Each result\r\n * or thrown error is sent to the isRetryable function which should return true\r\n * if the function should run again.\r\n */\r\nexport function retryable<T>(\r\n  fn: (attempt: number) => Promise<T>,\r\n  isRetryable: (attempt: number, error: any | null, result?: T) => boolean\r\n): Promise<T> {\r\n  const promise = new Promise<T>((accept, reject) => {\r\n    // eslint-disable-next-line @typescript-eslint/no-extra-semi\r\n    ;(async () => {\r\n      for (let attempt = 0; attempt < Infinity; attempt++) {\r\n        try {\r\n          const result = await fn(attempt)\r\n\r\n          if (!isRetryable(attempt, null, result)) {\r\n            accept(result)\r\n            return\r\n          }\r\n        } catch (e: any) {\r\n          if (!isRetryable(attempt, e)) {\r\n            reject(e)\r\n            return\r\n          }\r\n        }\r\n      }\r\n    })()\r\n  })\r\n\r\n  return promise\r\n}\r\n\r\nfunction dec2hex(dec: number) {\r\n  return ('0' + dec.toString(16)).substr(-2)\r\n}\r\n\r\n// Functions below taken from: https://stackoverflow.com/questions/63309409/creating-a-code-verifier-and-challenge-for-pkce-auth-on-spotify-api-in-reactjs\r\nexport function generatePKCEVerifier() {\r\n  const verifierLength = 56\r\n  const array = new Uint32Array(verifierLength)\r\n  if (typeof crypto === 'undefined') {\r\n    const charSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~'\r\n    const charSetLen = charSet.length\r\n    let verifier = ''\r\n    for (let i = 0; i < verifierLength; i++) {\r\n      verifier += charSet.charAt(Math.floor(Math.random() * charSetLen))\r\n    }\r\n    return verifier\r\n  }\r\n  crypto.getRandomValues(array)\r\n  return Array.from(array, dec2hex).join('')\r\n}\r\n\r\nasync function sha256(randomString: string) {\r\n  const encoder = new TextEncoder()\r\n  const encodedData = encoder.encode(randomString)\r\n  const hash = await crypto.subtle.digest('SHA-256', encodedData)\r\n  const bytes = new Uint8Array(hash)\r\n\r\n  return Array.from(bytes)\r\n    .map((c) => String.fromCharCode(c))\r\n    .join('')\r\n}\r\n\r\nfunction base64urlencode(str: string) {\r\n  return btoa(str).replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '')\r\n}\r\n\r\nexport async function generatePKCEChallenge(verifier: string) {\r\n  if (typeof crypto === 'undefined') {\r\n    console.warn(\r\n      'WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256.'\r\n    )\r\n    return verifier\r\n  }\r\n  const hashed = await sha256(verifier)\r\n  return base64urlencode(hashed)\r\n}\r\n", "export class AuthError extends Error {\r\n  status: number | undefined\r\n  protected __isAuthError = true\r\n\r\n  constructor(message: string, status?: number) {\r\n    super(message)\r\n    this.name = 'AuthError'\r\n    this.status = status\r\n  }\r\n}\r\n\r\nexport function isAuthError(error: unknown): error is AuthError {\r\n  return typeof error === 'object' && error !== null && '__isAuthError' in error\r\n}\r\n\r\nexport class AuthApiError extends AuthError {\r\n  status: number\r\n\r\n  constructor(message: string, status: number) {\r\n    super(message, status)\r\n    this.name = 'AuthApiError'\r\n    this.status = status\r\n  }\r\n\r\n  toJSON() {\r\n    return {\r\n      name: this.name,\r\n      message: this.message,\r\n      status: this.status,\r\n    }\r\n  }\r\n}\r\n\r\nexport function isAuthApiError(error: unknown): error is AuthApiError {\r\n  return isAuthError(error) && error.name === 'AuthApiError'\r\n}\r\n\r\nexport class AuthUnknownError extends AuthError {\r\n  originalError: unknown\r\n\r\n  constructor(message: string, originalError: unknown) {\r\n    super(message)\r\n    this.name = 'AuthUnknownError'\r\n    this.originalError = originalError\r\n  }\r\n}\r\n\r\nexport class CustomAuthError extends AuthError {\r\n  name: string\r\n  status: number\r\n  constructor(message: string, name: string, status: number) {\r\n    super(message)\r\n    this.name = name\r\n    this.status = status\r\n  }\r\n\r\n  toJSON() {\r\n    return {\r\n      name: this.name,\r\n      message: this.message,\r\n      status: this.status,\r\n    }\r\n  }\r\n}\r\n\r\nexport class AuthSessionMissingError extends CustomAuthError {\r\n  constructor() {\r\n    super('Auth session missing!', 'AuthSessionMissingError', 400)\r\n  }\r\n}\r\n\r\nexport class AuthInvalidTokenResponseError extends CustomAuthError {\r\n  constructor() {\r\n    super('Auth session or user missing', 'AuthInvalidTokenResponseError', 500)\r\n  }\r\n}\r\n\r\nexport class AuthInvalidCredentialsError extends CustomAuthError {\r\n  constructor(message: string) {\r\n    super(message, 'AuthInvalidCredentialsError', 400)\r\n  }\r\n}\r\n\r\nexport class AuthImplicitGrantRedirectError extends CustomAuthError {\r\n  details: { error: string; code: string } | null = null\r\n  constructor(message: string, details: { error: string; code: string } | null = null) {\r\n    super(message, 'AuthImplicitGrantRedirectError', 500)\r\n    this.details = details\r\n  }\r\n\r\n  toJSON() {\r\n    return {\r\n      name: this.name,\r\n      message: this.message,\r\n      status: this.status,\r\n      details: this.details,\r\n    }\r\n  }\r\n}\r\n\r\nexport class AuthPKCEGrantCodeExchangeError extends CustomAuthError {\r\n  details: { error: string; code: string } | null = null\r\n  constructor(message: string, details: { error: string; code: string } | null = null) {\r\n    super(message, 'AuthPKCEGrantCodeExchangeError', 500)\r\n    this.details = details\r\n  }\r\n\r\n  toJSON() {\r\n    return {\r\n      name: this.name,\r\n      message: this.message,\r\n      status: this.status,\r\n      details: this.details,\r\n    }\r\n  }\r\n}\r\n\r\nexport class AuthRetryableFetchError extends CustomAuthError {\r\n  constructor(message: string, status: number) {\r\n    super(message, 'AuthRetryableFetchError', status)\r\n  }\r\n}\r\n", "import { expiresAt, looksLikeFetchResponse } from './helpers'\r\nimport {\r\n  AuthResponse,\r\n  SSOResponse,\r\n  GenerateLinkProperties,\r\n  GenerateLinkResponse,\r\n  User,\r\n  UserResponse,\r\n} from './types'\r\nimport { AuthApiError, AuthRetryableFetchError, AuthUnknownError } from './errors'\r\n\r\nexport type Fetch = typeof fetch\r\n\r\nexport interface FetchOptions {\r\n  headers?: {\r\n    [key: string]: string\r\n  }\r\n  noResolveJson?: boolean\r\n}\r\n\r\nexport interface FetchParameters {\r\n  signal?: AbortSignal\r\n}\r\n\r\nexport type RequestMethodType = 'GET' | 'POST' | 'PUT' | 'DELETE'\r\n\r\nconst _getErrorMessage = (err: any): string =>\r\n  err.msg || err.message || err.error_description || err.error || JSON.stringify(err)\r\n\r\nconst handleError = async (error: unknown, reject: (reason?: any) => void) => {\r\n  const NETWORK_ERROR_CODES = [502, 503, 504]\r\n  if (!looksLikeFetchResponse(error)) {\r\n    reject(new AuthRetryableFetchError(_getErrorMessage(error), 0))\r\n  } else if (NETWORK_ERROR_CODES.includes(error.status)) {\r\n    // status in 500...599 range - server had an error, request might be retryed.\r\n    reject(new AuthRetryableFetchError(_getErrorMessage(error), error.status))\r\n  } else {\r\n    // got a response from server that is not in the 500...599 range - should not retry\r\n    error\r\n      .json()\r\n      .then((err) => {\r\n        reject(new AuthApiError(_getErrorMessage(err), error.status || 500))\r\n      })\r\n      .catch((e) => {\r\n        // not a valid json response\r\n        reject(new AuthUnknownError(_getErrorMessage(e), e))\r\n      })\r\n  }\r\n}\r\n\r\nconst _getRequestParams = (\r\n  method: RequestMethodType,\r\n  options?: FetchOptions,\r\n  parameters?: FetchParameters,\r\n  body?: object\r\n) => {\r\n  const params: { [k: string]: any } = { method, headers: options?.headers || {} }\r\n\r\n  if (method === 'GET') {\r\n    return params\r\n  }\r\n\r\n  params.headers = { 'Content-Type': 'application/json;charset=UTF-8', ...options?.headers }\r\n  params.body = JSON.stringify(body)\r\n  return { ...params, ...parameters }\r\n}\r\n\r\ninterface GotrueRequestOptions extends FetchOptions {\r\n  jwt?: string\r\n  redirectTo?: string\r\n  body?: object\r\n  query?: { [key: string]: string }\r\n  /**\r\n   * Function that transforms api response from gotrue into a desirable / standardised format\r\n   */\r\n  xform?: (data: any) => any\r\n}\r\n\r\nexport async function _request(\r\n  fetcher: Fetch,\r\n  method: RequestMethodType,\r\n  url: string,\r\n  options?: GotrueRequestOptions\r\n) {\r\n  const headers = { ...options?.headers }\r\n  if (options?.jwt) {\r\n    headers['Authorization'] = `Bearer ${options.jwt}`\r\n  }\r\n  const qs = options?.query ?? {}\r\n  if (options?.redirectTo) {\r\n    qs['redirect_to'] = options.redirectTo\r\n  }\r\n  const queryString = Object.keys(qs).length ? '?' + new URLSearchParams(qs).toString() : ''\r\n  const data = await _handleRequest(\r\n    fetcher,\r\n    method,\r\n    url + queryString,\r\n    { headers, noResolveJson: options?.noResolveJson },\r\n    {},\r\n    options?.body\r\n  )\r\n  return options?.xform ? options?.xform(data) : { data: { ...data }, error: null }\r\n}\r\n\r\nasync function _handleRequest(\r\n  fetcher: Fetch,\r\n  method: RequestMethodType,\r\n  url: string,\r\n  options?: FetchOptions,\r\n  parameters?: FetchParameters,\r\n  body?: object\r\n): Promise<any> {\r\n  return new Promise((resolve, reject) => {\r\n    fetcher(url, _getRequestParams(method, options, parameters, body))\r\n      .then((result) => {\r\n        if (!result.ok) throw result\r\n        if (options?.noResolveJson) return result\r\n        return result.json()\r\n      })\r\n      .then((data) => resolve(data))\r\n      .catch((error) => handleError(error, reject))\r\n  })\r\n}\r\n\r\nexport function _sessionResponse(data: any): AuthResponse {\r\n  let session = null\r\n  if (hasSession(data)) {\r\n    session = { ...data }\r\n    session.expires_at = expiresAt(data.expires_in)\r\n  }\r\n  const user: User = data.user ?? (data as User)\r\n  return { data: { session, user }, error: null }\r\n}\r\n\r\nexport function _userResponse(data: any): UserResponse {\r\n  const user: User = data.user ?? (data as User)\r\n  return { data: { user }, error: null }\r\n}\r\n\r\nexport function _ssoResponse(data: any): SSOResponse {\r\n  return { data, error: null }\r\n}\r\n\r\nexport function _generateLinkResponse(data: any): GenerateLinkResponse {\r\n  const { action_link, email_otp, hashed_token, redirect_to, verification_type, ...rest } = data\r\n\r\n  const properties: GenerateLinkProperties = {\r\n    action_link,\r\n    email_otp,\r\n    hashed_token,\r\n    redirect_to,\r\n    verification_type,\r\n  }\r\n\r\n  const user: User = { ...rest }\r\n  return {\r\n    data: {\r\n      properties,\r\n      user,\r\n    },\r\n    error: null,\r\n  }\r\n}\r\n\r\nexport function _noResolveJsonResponse(data: any): Response {\r\n  return data\r\n}\r\n\r\n/**\r\n * hasSession checks if the response object contains a valid session\r\n * @param data A response object\r\n * @returns true if a session is in the response\r\n */\r\nfunction hasSession(data: any): boolean {\r\n  return data.access_token && data.refresh_token && data.expires_in\r\n}\r\n", "import {\r\n  Fetch,\r\n  _generateLinkResponse,\r\n  _noResolveJsonResponse,\r\n  _request,\r\n  _userResponse,\r\n} from './lib/fetch'\r\nimport { resolveFetch } from './lib/helpers'\r\nimport {\r\n  AdminUserAttributes,\r\n  GenerateLinkParams,\r\n  GenerateLinkResponse,\r\n  Pagination,\r\n  User,\r\n  UserResponse,\r\n  GoTrueAdminMFAApi,\r\n  AuthMFAAdminDeleteFactorParams,\r\n  AuthMFAAdminDeleteFactorResponse,\r\n  AuthMFAAdminListFactorsParams,\r\n  AuthMFAAdminListFactorsResponse,\r\n  PageParams,\r\n} from './lib/types'\r\nimport { AuthError, isAuthError } from './lib/errors'\r\n\r\nexport default class GoTrueAdminApi {\r\n  /** Contains all MFA administration methods. */\r\n  mfa: GoTrueAdminMFAApi\r\n\r\n  protected url: string\r\n  protected headers: {\r\n    [key: string]: string\r\n  }\r\n  protected fetch: Fetch\r\n\r\n  constructor({\r\n    url = '',\r\n    headers = {},\r\n    fetch,\r\n  }: {\r\n    url: string\r\n    headers?: {\r\n      [key: string]: string\r\n    }\r\n    fetch?: Fetch\r\n  }) {\r\n    this.url = url\r\n    this.headers = headers\r\n    this.fetch = resolveFetch(fetch)\r\n    this.mfa = {\r\n      listFactors: this._listFactors.bind(this),\r\n      deleteFactor: this._deleteFactor.bind(this),\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes a logged-in session.\r\n   * @param jwt A valid, logged-in JWT.\r\n   */\r\n  async signOut(jwt: string): Promise<{ data: null; error: AuthError | null }> {\r\n    try {\r\n      await _request(this.fetch, 'POST', `${this.url}/logout`, {\r\n        headers: this.headers,\r\n        jwt,\r\n        noResolveJson: true,\r\n      })\r\n      return { data: null, error: null }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: null, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sends an invite link to an email address.\r\n   * @param email The email address of the user.\r\n   * @param options Additional options to be included when inviting.\r\n   */\r\n  async inviteUserByEmail(\r\n    email: string,\r\n    options: {\r\n      /** A custom data object to store additional metadata about the user. This maps to the `auth.users.user_metadata` column. */\r\n      data?: object\r\n\r\n      /** The URL which will be appended to the email link sent to the user's email address. Once clicked the user will end up on this URL. */\r\n      redirectTo?: string\r\n    } = {}\r\n  ): Promise<UserResponse> {\r\n    try {\r\n      return await _request(this.fetch, 'POST', `${this.url}/invite`, {\r\n        body: { email, data: options.data },\r\n        headers: this.headers,\r\n        redirectTo: options.redirectTo,\r\n        xform: _userResponse,\r\n      })\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { user: null }, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generates email links and OTPs to be sent via a custom email provider.\r\n   * @param email The user's email.\r\n   * @param options.password User password. For signup only.\r\n   * @param options.data Optional user metadata. For signup only.\r\n   * @param options.redirectTo The redirect url which should be appended to the generated link\r\n   */\r\n  async generateLink(params: GenerateLinkParams): Promise<GenerateLinkResponse> {\r\n    try {\r\n      const { options, ...rest } = params\r\n      const body: any = { ...rest, ...options }\r\n      if ('newEmail' in rest) {\r\n        // replace newEmail with new_email in request body\r\n        body.new_email = rest?.newEmail\r\n        delete body['newEmail']\r\n      }\r\n      return await _request(this.fetch, 'POST', `${this.url}/admin/generate_link`, {\r\n        body: body,\r\n        headers: this.headers,\r\n        xform: _generateLinkResponse,\r\n        redirectTo: options?.redirectTo,\r\n      })\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return {\r\n          data: {\r\n            properties: null,\r\n            user: null,\r\n          },\r\n          error,\r\n        }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  // User Admin API\r\n  /**\r\n   * Creates a new user.\r\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\r\n   */\r\n  async createUser(attributes: AdminUserAttributes): Promise<UserResponse> {\r\n    try {\r\n      return await _request(this.fetch, 'POST', `${this.url}/admin/users`, {\r\n        body: attributes,\r\n        headers: this.headers,\r\n        xform: _userResponse,\r\n      })\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { user: null }, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get a list of users.\r\n   *\r\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\r\n   * @param params An object which supports `page` and `perPage` as numbers, to alter the paginated results.\r\n   */\r\n  async listUsers(\r\n    params?: PageParams\r\n  ): Promise<\r\n    | { data: { users: User[]; aud: string } & Pagination; error: null }\r\n    | { data: { users: [] }; error: AuthError }\r\n  > {\r\n    try {\r\n      const pagination: Pagination = { nextPage: null, lastPage: 0, total: 0 }\r\n      const response = await _request(this.fetch, 'GET', `${this.url}/admin/users`, {\r\n        headers: this.headers,\r\n        noResolveJson: true,\r\n        query: {\r\n          page: params?.page?.toString() ?? '',\r\n          per_page: params?.perPage?.toString() ?? '',\r\n        },\r\n        xform: _noResolveJsonResponse,\r\n      })\r\n      if (response.error) throw response.error\r\n\r\n      const users = await response.json()\r\n      const total = response.headers.get('x-total-count') ?? 0\r\n      const links = response.headers.get('link')?.split(',') ?? []\r\n      if (links.length > 0) {\r\n        links.forEach((link: string) => {\r\n          const page = parseInt(link.split(';')[0].split('=')[1].substring(0, 1))\r\n          const rel = JSON.parse(link.split(';')[1].split('=')[1])\r\n          pagination[`${rel}Page`] = page\r\n        })\r\n\r\n        pagination.total = parseInt(total)\r\n      }\r\n      return { data: { ...users, ...pagination }, error: null }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { users: [] }, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get user by id.\r\n   *\r\n   * @param uid The user's unique identifier\r\n   *\r\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\r\n   */\r\n  async getUserById(uid: string): Promise<UserResponse> {\r\n    try {\r\n      return await _request(this.fetch, 'GET', `${this.url}/admin/users/${uid}`, {\r\n        headers: this.headers,\r\n        xform: _userResponse,\r\n      })\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { user: null }, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates the user data.\r\n   *\r\n   * @param attributes The data you want to update.\r\n   *\r\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\r\n   */\r\n  async updateUserById(uid: string, attributes: AdminUserAttributes): Promise<UserResponse> {\r\n    try {\r\n      return await _request(this.fetch, 'PUT', `${this.url}/admin/users/${uid}`, {\r\n        body: attributes,\r\n        headers: this.headers,\r\n        xform: _userResponse,\r\n      })\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { user: null }, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete a user. Requires a `service_role` key.\r\n   *\r\n   * @param id The user id you want to remove.\r\n   * @param shouldSoftDelete If true, then the user will be soft-deleted from the auth schema.\r\n   * Defaults to false for backward compatibility.\r\n   *\r\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\r\n   */\r\n  async deleteUser(id: string, shouldSoftDelete = false): Promise<UserResponse> {\r\n    try {\r\n      return await _request(this.fetch, 'DELETE', `${this.url}/admin/users/${id}`, {\r\n        headers: this.headers,\r\n        body: {\r\n          should_soft_delete: shouldSoftDelete,\r\n        },\r\n        xform: _userResponse,\r\n      })\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { user: null }, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  private async _listFactors(\r\n    params: AuthMFAAdminListFactorsParams\r\n  ): Promise<AuthMFAAdminListFactorsResponse> {\r\n    try {\r\n      const { data, error } = await _request(\r\n        this.fetch,\r\n        'GET',\r\n        `${this.url}/admin/users/${params.userId}/factors`,\r\n        {\r\n          headers: this.headers,\r\n          xform: (factors: any) => {\r\n            return { data: { factors }, error: null }\r\n          },\r\n        }\r\n      )\r\n      return { data, error }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: null, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  private async _deleteFactor(\r\n    params: AuthMFAAdminDeleteFactorParams\r\n  ): Promise<AuthMFAAdminDeleteFactorResponse> {\r\n    try {\r\n      const data = await _request(\r\n        this.fetch,\r\n        'DELETE',\r\n        `${this.url}/admin/users/${params.userId}/factors/${params.id}`,\r\n        {\r\n          headers: this.headers,\r\n        }\r\n      )\r\n\r\n      return { data, error: null }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: null, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n}\r\n", "// Generated by genversion.\r\nexport const version = '2.30.0'\r\n", "import { version } from './version'\r\nexport const GOTRUE_URL = 'http://localhost:9999'\r\nexport const STORAGE_KEY = 'supabase.auth.token'\r\nexport const AUDIENCE = ''\r\nexport const DEFAULT_HEADERS = { 'X-Client-Info': `gotrue-js/${version}` }\r\nexport const EXPIRY_MARGIN = 10 // in seconds\r\nexport const NETWORK_FAILURE = {\r\n  MAX_RETRIES: 10,\r\n  RETRY_INTERVAL: 2, // in deciseconds\r\n}\r\n", "import { supportsLocalStorage } from './helpers'\r\nimport { SupportedStorage } from './types'\r\n\r\nconst localStorageAdapter: SupportedStorage = {\r\n  getItem: (key) => {\r\n    if (!supportsLocalStorage()) {\r\n      return null\r\n    }\r\n\r\n    return globalThis.localStorage.getItem(key)\r\n  },\r\n  setItem: (key, value) => {\r\n    if (!supportsLocalStorage()) {\r\n      return\r\n    }\r\n\r\n    globalThis.localStorage.setItem(key, value)\r\n  },\r\n  removeItem: (key) => {\r\n    if (!supportsLocalStorage()) {\r\n      return\r\n    }\r\n\r\n    globalThis.localStorage.removeItem(key)\r\n  },\r\n}\r\n\r\nexport default localStorageAdapter\r\n", "/**\r\n * https://mathiasbynens.be/notes/globalthis\r\n */\r\nexport function polyfillGlobalThis() {\r\n  if (typeof globalThis === 'object') return\r\n  try {\r\n    Object.defineProperty(Object.prototype, '__magic__', {\r\n      get: function () {\r\n        return this\r\n      },\r\n      configurable: true,\r\n    })\r\n    // @ts-expect-error 'Allow access to magic'\r\n    __magic__.globalThis = __magic__\r\n    // @ts-expect-error 'Allow access to magic'\r\n    delete Object.prototype.__magic__\r\n  } catch (e) {\r\n    if (typeof self !== 'undefined') {\r\n      // @ts-expect-error 'Allow access to globals'\r\n      self.globalThis = self\r\n    }\r\n  }\r\n}\r\n", "import GoTrueAdminApi from './GoTrueAdminApi'\r\nimport { DEFAULT_HEADERS, EXPIRY_MARGIN, GOTRUE_URL, STORAGE_KEY } from './lib/constants'\r\nimport {\r\n  AuthError,\r\n  AuthImplicitGrantRedirectError,\r\n  AuthPKCEGrantCodeExchangeError,\r\n  AuthInvalidCredentialsError,\r\n  AuthRetryableFetchError,\r\n  AuthSessionMissingError,\r\n  AuthInvalidTokenResponseError,\r\n  AuthUnknownError,\r\n  isAuthApiError,\r\n  isAuthError,\r\n} from './lib/errors'\r\nimport { Fetch, _request, _sessionResponse, _userResponse, _ssoResponse } from './lib/fetch'\r\nimport {\r\n  decodeJWTPayload,\r\n  Deferred,\r\n  getItemAsync,\r\n  getParameterByName,\r\n  isBrowser,\r\n  removeItemAsync,\r\n  resolveFetch,\r\n  setItemAsync,\r\n  uuid,\r\n  retryable,\r\n  sleep,\r\n  generatePKCEVerifier,\r\n  generatePKCEChallenge,\r\n  supportsLocalStorage,\r\n} from './lib/helpers'\r\nimport localStorageAdapter from './lib/local-storage'\r\nimport { polyfillGlobalThis } from './lib/polyfills'\r\n\r\nimport type {\r\n  AuthChangeEvent,\r\n  AuthResponse,\r\n  AuthTokenResponse,\r\n  CallRefreshTokenResult,\r\n  GoTrueClientOptions,\r\n  InitializeResult,\r\n  OAuthResponse,\r\n  SSOResponse,\r\n  Provider,\r\n  Session,\r\n  SignInWithIdTokenCredentials,\r\n  SignInWithOAuthCredentials,\r\n  SignInWithPasswordCredentials,\r\n  SignInWithPasswordlessCredentials,\r\n  SignUpWithPasswordCredentials,\r\n  SignInWithSSO,\r\n  Subscription,\r\n  SupportedStorage,\r\n  User,\r\n  UserAttributes,\r\n  UserResponse,\r\n  VerifyOtpParams,\r\n  GoTrueMFAApi,\r\n  MFAEnrollParams,\r\n  AuthMFAEnrollResponse,\r\n  MFAChallengeParams,\r\n  AuthMFAChallengeResponse,\r\n  MFAUnenrollParams,\r\n  AuthMFAUnenrollResponse,\r\n  MFAVerifyParams,\r\n  AuthMFAVerifyResponse,\r\n  AuthMFAListFactorsResponse,\r\n  AMREntry,\r\n  AuthMFAGetAuthenticatorAssuranceLevelResponse,\r\n  AuthenticatorAssuranceLevels,\r\n  Factor,\r\n  MFAChallengeAndVerifyParams,\r\n  ResendParams,\r\n  AuthFlowType,\r\n} from './lib/types'\r\n\r\npolyfillGlobalThis() // Make \"globalThis\" available\r\n\r\nconst DEFAULT_OPTIONS: Omit<Required<GoTrueClientOptions>, 'fetch' | 'storage'> = {\r\n  url: GOTRUE_URL,\r\n  storageKey: STORAGE_KEY,\r\n  autoRefreshToken: true,\r\n  persistSession: true,\r\n  detectSessionInUrl: true,\r\n  headers: DEFAULT_HEADERS,\r\n  flowType: 'implicit',\r\n}\r\n\r\n/** Current session will be checked for refresh at this interval. */\r\nconst AUTO_REFRESH_TICK_DURATION = 30 * 1000\r\n\r\n/**\r\n * A token refresh will be attempted this many ticks before the current session expires. */\r\nconst AUTO_REFRESH_TICK_THRESHOLD = 3\r\n\r\nexport default class GoTrueClient {\r\n  /**\r\n   * Namespace for the GoTrue admin methods.\r\n   * These methods should only be used in a trusted server-side environment.\r\n   */\r\n  admin: GoTrueAdminApi\r\n  /**\r\n   * Namespace for the MFA methods.\r\n   */\r\n  mfa: GoTrueMFAApi\r\n  /**\r\n   * The storage key used to identify the values saved in localStorage\r\n   */\r\n  protected storageKey: string\r\n\r\n  /**\r\n   * The session object for the currently logged in user. If null, it means there isn't a logged-in user.\r\n   * Only used if persistSession is false.\r\n   */\r\n  protected inMemorySession: Session | null\r\n\r\n  protected flowType: AuthFlowType\r\n\r\n  protected autoRefreshToken: boolean\r\n  protected persistSession: boolean\r\n  protected storage: SupportedStorage\r\n  protected stateChangeEmitters: Map<string, Subscription> = new Map()\r\n  protected autoRefreshTicker: ReturnType<typeof setInterval> | null = null\r\n  protected visibilityChangedCallback: (() => Promise<any>) | null = null\r\n  protected refreshingDeferred: Deferred<CallRefreshTokenResult> | null = null\r\n  /**\r\n   * Keeps track of the async client initialization.\r\n   * When null or not yet resolved the auth state is `unknown`\r\n   * Once resolved the the auth state is known and it's save to call any further client methods.\r\n   * Keep extra care to never reject or throw uncaught errors\r\n   */\r\n  protected initializePromise: Promise<InitializeResult> | null = null\r\n  protected detectSessionInUrl = true\r\n  protected url: string\r\n  protected headers: {\r\n    [key: string]: string\r\n  }\r\n  protected fetch: Fetch\r\n\r\n  /**\r\n   * Used to broadcast state change events to other tabs listening.\r\n   */\r\n  protected broadcastChannel: BroadcastChannel | null = null\r\n\r\n  /**\r\n   * Create a new client for use in the browser.\r\n   */\r\n  constructor(options: GoTrueClientOptions) {\r\n    const settings = { ...DEFAULT_OPTIONS, ...options }\r\n    this.inMemorySession = null\r\n    this.storageKey = settings.storageKey\r\n    this.autoRefreshToken = settings.autoRefreshToken\r\n    this.persistSession = settings.persistSession\r\n    this.storage = settings.storage || localStorageAdapter\r\n    this.admin = new GoTrueAdminApi({\r\n      url: settings.url,\r\n      headers: settings.headers,\r\n      fetch: settings.fetch,\r\n    })\r\n\r\n    this.url = settings.url\r\n    this.headers = settings.headers\r\n    this.fetch = resolveFetch(settings.fetch)\r\n    this.detectSessionInUrl = settings.detectSessionInUrl\r\n    this.flowType = settings.flowType\r\n\r\n    this.mfa = {\r\n      verify: this._verify.bind(this),\r\n      enroll: this._enroll.bind(this),\r\n      unenroll: this._unenroll.bind(this),\r\n      challenge: this._challenge.bind(this),\r\n      listFactors: this._listFactors.bind(this),\r\n      challengeAndVerify: this._challengeAndVerify.bind(this),\r\n      getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this),\r\n    }\r\n\r\n    if (this.persistSession && this.storage === localStorageAdapter && !supportsLocalStorage()) {\r\n      console.warn(\r\n        `No storage option exists to persist the session, which may result in unexpected behavior when using auth.\r\n        If you want to set persistSession to true, please provide a storage option or you may set persistSession to false to disable this warning.`\r\n      )\r\n    }\r\n\r\n    if (isBrowser() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {\r\n      try {\r\n        this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey)\r\n      } catch (e: any) {\r\n        console.error(\r\n          'Failed to create a new BroadcastChannel, multi-tab state changes will not be available',\r\n          e\r\n        )\r\n      }\r\n\r\n      this.broadcastChannel?.addEventListener('message', async (event) => {\r\n        await this._notifyAllSubscribers(event.data.event, event.data.session, false) // broadcast = false so we don't get an endless loop of messages\r\n      })\r\n    }\r\n\r\n    this.initialize()\r\n  }\r\n\r\n  /**\r\n   * Initializes the client session either from the url or from storage.\r\n   * This method is automatically called when instantiating the client, but should also be called\r\n   * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).\r\n   */\r\n  initialize(): Promise<InitializeResult> {\r\n    if (!this.initializePromise) {\r\n      this.initializePromise = this._initialize()\r\n    }\r\n\r\n    return this.initializePromise\r\n  }\r\n\r\n  /**\r\n   * IMPORTANT:\r\n   * 1. Never throw in this method, as it is called from the constructor\r\n   * 2. Never return a session from this method as it would be cached over\r\n   *    the whole lifetime of the client\r\n   */\r\n  private async _initialize(): Promise<InitializeResult> {\r\n    if (this.initializePromise) {\r\n      return this.initializePromise\r\n    }\r\n\r\n    try {\r\n      const isPKCEFlow = isBrowser() ? await this._isPKCEFlow() : false\r\n      if (isPKCEFlow || (this.detectSessionInUrl && this._isImplicitGrantFlow())) {\r\n        const { data, error } = await this._getSessionFromUrl(isPKCEFlow)\r\n        if (error) {\r\n          // failed login attempt via url,\r\n          // remove old session as in verifyOtp, signUp and signInWith*\r\n          await this._removeSession()\r\n\r\n          return { error }\r\n        }\r\n\r\n        const { session, redirectType } = data\r\n\r\n        await this._saveSession(session)\r\n\r\n        setTimeout(async () => {\r\n          if (redirectType === 'recovery') {\r\n            await this._notifyAllSubscribers('PASSWORD_RECOVERY', session)\r\n          } else {\r\n            await this._notifyAllSubscribers('SIGNED_IN', session)\r\n          }\r\n        }, 0)\r\n\r\n        return { error: null }\r\n      }\r\n\r\n      // no login attempt via callback url try to recover session from storage\r\n      await this._recoverAndRefresh()\r\n      return { error: null }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { error }\r\n      }\r\n\r\n      return {\r\n        error: new AuthUnknownError('Unexpected error during initialization', error),\r\n      }\r\n    } finally {\r\n      await this._handleVisibilityChange()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a new user.\r\n   *\r\n   * Be aware that if a user account exists in the system you may get back an\r\n   * error message that attempts to hide this information from the user.\r\n   * This method has support for PKCE via email signups. The PKCE flow cannot be used when autoconfirm is enabled.\r\n   *\r\n   * @returns A logged-in session if the server has \"autoconfirm\" ON\r\n   * @returns A user if the server has \"autoconfirm\" OFF\r\n   */\r\n  async signUp(credentials: SignUpWithPasswordCredentials): Promise<AuthResponse> {\r\n    try {\r\n      await this._removeSession()\r\n\r\n      let res: AuthResponse\r\n      if ('email' in credentials) {\r\n        const { email, password, options } = credentials\r\n        let codeChallenge: string | null = null\r\n        let codeChallengeMethod: string | null = null\r\n        if (this.flowType === 'pkce') {\r\n          const codeVerifier = generatePKCEVerifier()\r\n          await setItemAsync(this.storage, `${this.storageKey}-code-verifier`, codeVerifier)\r\n          codeChallenge = await generatePKCEChallenge(codeVerifier)\r\n          codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256'\r\n        }\r\n        res = await _request(this.fetch, 'POST', `${this.url}/signup`, {\r\n          headers: this.headers,\r\n          redirectTo: options?.emailRedirectTo,\r\n          body: {\r\n            email,\r\n            password,\r\n            data: options?.data ?? {},\r\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\r\n            code_challenge: codeChallenge,\r\n            code_challenge_method: codeChallengeMethod,\r\n          },\r\n          xform: _sessionResponse,\r\n        })\r\n      } else if ('phone' in credentials) {\r\n        const { phone, password, options } = credentials\r\n        res = await _request(this.fetch, 'POST', `${this.url}/signup`, {\r\n          headers: this.headers,\r\n          body: {\r\n            phone,\r\n            password,\r\n            data: options?.data ?? {},\r\n            channel: options?.channel ?? 'sms',\r\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\r\n          },\r\n          xform: _sessionResponse,\r\n        })\r\n      } else {\r\n        throw new AuthInvalidCredentialsError(\r\n          'You must provide either an email or phone number and a password'\r\n        )\r\n      }\r\n\r\n      const { data, error } = res\r\n\r\n      if (error || !data) {\r\n        return { data: { user: null, session: null }, error: error }\r\n      }\r\n\r\n      const session: Session | null = data.session\r\n      const user: User | null = data.user\r\n\r\n      if (data.session) {\r\n        await this._saveSession(data.session)\r\n        await this._notifyAllSubscribers('SIGNED_IN', session)\r\n      }\r\n\r\n      return { data: { user, session }, error: null }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { user: null, session: null }, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log in an existing user with an email and password or phone and password.\r\n   *\r\n   * Be aware that you may get back an error message that will not distinguish\r\n   * between the cases where the account does not exist or that the\r\n   * email/phone and password combination is wrong or that the account can only\r\n   * be accessed via social login.\r\n   */\r\n  async signInWithPassword(credentials: SignInWithPasswordCredentials): Promise<AuthTokenResponse> {\r\n    try {\r\n      await this._removeSession()\r\n\r\n      let res: AuthResponse\r\n      if ('email' in credentials) {\r\n        const { email, password, options } = credentials\r\n        res = await _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\r\n          headers: this.headers,\r\n          body: {\r\n            email,\r\n            password,\r\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\r\n          },\r\n          xform: _sessionResponse,\r\n        })\r\n      } else if ('phone' in credentials) {\r\n        const { phone, password, options } = credentials\r\n        res = await _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\r\n          headers: this.headers,\r\n          body: {\r\n            phone,\r\n            password,\r\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\r\n          },\r\n          xform: _sessionResponse,\r\n        })\r\n      } else {\r\n        throw new AuthInvalidCredentialsError(\r\n          'You must provide either an email or phone number and a password'\r\n        )\r\n      }\r\n      const { data, error } = res\r\n\r\n      if (error) {\r\n        return { data: { user: null, session: null }, error }\r\n      } else if (!data || !data.session || !data.user) {\r\n        return { data: { user: null, session: null }, error: new AuthInvalidTokenResponseError() }\r\n      }\r\n      if (data.session) {\r\n        await this._saveSession(data.session)\r\n        await this._notifyAllSubscribers('SIGNED_IN', data.session)\r\n      }\r\n      return { data: { user: data.user, session: data.session }, error }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { user: null, session: null }, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log in an existing user via a third-party provider.\r\n   * This method supports the PKCE flow.\r\n   */\r\n  async signInWithOAuth(credentials: SignInWithOAuthCredentials): Promise<OAuthResponse> {\r\n    await this._removeSession()\r\n\r\n    return await this._handleProviderSignIn(credentials.provider, {\r\n      redirectTo: credentials.options?.redirectTo,\r\n      scopes: credentials.options?.scopes,\r\n      queryParams: credentials.options?.queryParams,\r\n      skipBrowserRedirect: credentials.options?.skipBrowserRedirect,\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Log in an existing user by exchanging an Auth Code issued during the PKCE flow.\r\n   */\r\n  async exchangeCodeForSession(authCode: string): Promise<AuthTokenResponse> {\r\n    const codeVerifier = await getItemAsync(this.storage, `${this.storageKey}-code-verifier`)\r\n    const { data, error } = await _request(\r\n      this.fetch,\r\n      'POST',\r\n      `${this.url}/token?grant_type=pkce`,\r\n      {\r\n        headers: this.headers,\r\n        body: {\r\n          auth_code: authCode,\r\n          code_verifier: codeVerifier,\r\n        },\r\n        xform: _sessionResponse,\r\n      }\r\n    )\r\n    await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`)\r\n    if (error) {\r\n      return { data: { user: null, session: null }, error }\r\n    } else if (!data || !data.session || !data.user) {\r\n      return { data: { user: null, session: null }, error: new AuthInvalidTokenResponseError() }\r\n    }\r\n    if (data.session) {\r\n      await this._saveSession(data.session)\r\n      await this._notifyAllSubscribers('SIGNED_IN', data.session)\r\n    }\r\n    return { data, error }\r\n  }\r\n\r\n  /**\r\n   * Allows signing in with an ID token issued by certain supported providers.\r\n   * The ID token is verified for validity and a new session is established.\r\n   *\r\n   * @experimental\r\n   */\r\n  async signInWithIdToken(credentials: SignInWithIdTokenCredentials): Promise<AuthTokenResponse> {\r\n    await this._removeSession()\r\n\r\n    try {\r\n      const { options, provider, token, nonce } = credentials\r\n\r\n      const res = await _request(this.fetch, 'POST', `${this.url}/token?grant_type=id_token`, {\r\n        headers: this.headers,\r\n        body: {\r\n          provider,\r\n          id_token: token,\r\n          nonce,\r\n          gotrue_meta_security: { captcha_token: options?.captchaToken },\r\n        },\r\n        xform: _sessionResponse,\r\n      })\r\n\r\n      const { data, error } = res\r\n      if (error) {\r\n        return { data: { user: null, session: null }, error }\r\n      } else if (!data || !data.session || !data.user) {\r\n        return {\r\n          data: { user: null, session: null },\r\n          error: new AuthInvalidTokenResponseError(),\r\n        }\r\n      }\r\n      if (data.session) {\r\n        await this._saveSession(data.session)\r\n        await this._notifyAllSubscribers('SIGNED_IN', data.session)\r\n      }\r\n      return { data, error }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { user: null, session: null }, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log in a user using magiclink or a one-time password (OTP).\r\n   *\r\n   * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.\r\n   * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.\r\n   * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.\r\n   *\r\n   * Be aware that you may get back an error message that will not distinguish\r\n   * between the cases where the account does not exist or, that the account\r\n   * can only be accessed via social login.\r\n   *\r\n   * Do note that you will need to configure a Whatsapp sender on Twilio\r\n   * if you are using phone sign in with the 'whatsapp' channel. The whatsapp\r\n   * channel is not supported on other providers\r\n   * at this time.\r\n   * This method supports PKCE when an email is passed.\r\n   */\r\n  async signInWithOtp(credentials: SignInWithPasswordlessCredentials): Promise<AuthResponse> {\r\n    try {\r\n      await this._removeSession()\r\n\r\n      if ('email' in credentials) {\r\n        const { email, options } = credentials\r\n        let codeChallenge: string | null = null\r\n        let codeChallengeMethod: string | null = null\r\n        if (this.flowType === 'pkce') {\r\n          const codeVerifier = generatePKCEVerifier()\r\n          await setItemAsync(this.storage, `${this.storageKey}-code-verifier`, codeVerifier)\r\n          codeChallenge = await generatePKCEChallenge(codeVerifier)\r\n          codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256'\r\n        }\r\n        const { error } = await _request(this.fetch, 'POST', `${this.url}/otp`, {\r\n          headers: this.headers,\r\n          body: {\r\n            email,\r\n            data: options?.data ?? {},\r\n            create_user: options?.shouldCreateUser ?? true,\r\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\r\n            code_challenge: codeChallenge,\r\n            code_challenge_method: codeChallengeMethod,\r\n          },\r\n          redirectTo: options?.emailRedirectTo,\r\n        })\r\n        return { data: { user: null, session: null }, error }\r\n      }\r\n      if ('phone' in credentials) {\r\n        const { phone, options } = credentials\r\n        const { error } = await _request(this.fetch, 'POST', `${this.url}/otp`, {\r\n          headers: this.headers,\r\n          body: {\r\n            phone,\r\n            data: options?.data ?? {},\r\n            create_user: options?.shouldCreateUser ?? true,\r\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\r\n            channel: options?.channel ?? 'sms',\r\n          },\r\n        })\r\n        return { data: { user: null, session: null }, error }\r\n      }\r\n      throw new AuthInvalidCredentialsError('You must provide either an email or phone number.')\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { user: null, session: null }, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Log in a user given a User supplied OTP received via mobile.\r\n   */\r\n  async verifyOtp(params: VerifyOtpParams): Promise<AuthResponse> {\r\n    try {\r\n      if (params.type !== 'email_change' && params.type !== 'phone_change') {\r\n        // we don't want to remove the authenticated session if the user is performing an email_change or phone_change verification\r\n        await this._removeSession()\r\n      }\r\n      const { data, error } = await _request(this.fetch, 'POST', `${this.url}/verify`, {\r\n        headers: this.headers,\r\n        body: {\r\n          ...params,\r\n          gotrue_meta_security: { captcha_token: params.options?.captchaToken },\r\n        },\r\n        redirectTo: params.options?.redirectTo,\r\n        xform: _sessionResponse,\r\n      })\r\n\r\n      if (error) {\r\n        throw error\r\n      }\r\n\r\n      if (!data) {\r\n        throw new Error('An error occurred on token verification.')\r\n      }\r\n\r\n      const session: Session | null = data.session\r\n      const user: User = data.user\r\n\r\n      if (session?.access_token) {\r\n        await this._saveSession(session as Session)\r\n        await this._notifyAllSubscribers('SIGNED_IN', session)\r\n      }\r\n\r\n      return { data: { user, session }, error: null }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { user: null, session: null }, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Attempts a single-sign on using an enterprise Identity Provider. A\r\n   * successful SSO attempt will redirect the current page to the identity\r\n   * provider authorization page. The redirect URL is implementation and SSO\r\n   * protocol specific.\r\n   *\r\n   * You can use it by providing a SSO domain. Typically you can extract this\r\n   * domain by asking users for their email address. If this domain is\r\n   * registered on the Auth instance the redirect will use that organization's\r\n   * currently active SSO Identity Provider for the login.\r\n   *\r\n   * If you have built an organization-specific login page, you can use the\r\n   * organization's SSO Identity Provider UUID directly instead.\r\n   */\r\n  async signInWithSSO(params: SignInWithSSO): Promise<SSOResponse> {\r\n    try {\r\n      await this._removeSession()\r\n\r\n      return await _request(this.fetch, 'POST', `${this.url}/sso`, {\r\n        body: {\r\n          ...('providerId' in params ? { provider_id: params.providerId } : null),\r\n          ...('domain' in params ? { domain: params.domain } : null),\r\n          redirect_to: params.options?.redirectTo ?? undefined,\r\n          ...(params?.options?.captchaToken\r\n            ? { gotrue_meta_security: { captcha_token: params.options.captchaToken } }\r\n            : null),\r\n          skip_http_redirect: true, // fetch does not handle redirects\r\n        },\r\n        headers: this.headers,\r\n        xform: _ssoResponse,\r\n      })\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: null, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sends a reauthentication OTP to the user's email or phone number.\r\n   * Requires the user to be signed-in.\r\n   */\r\n  async reauthenticate(): Promise<AuthResponse> {\r\n    try {\r\n      const {\r\n        data: { session },\r\n        error: sessionError,\r\n      } = await this.getSession()\r\n      if (sessionError) throw sessionError\r\n      if (!session) throw new AuthSessionMissingError()\r\n\r\n      const { error } = await _request(this.fetch, 'GET', `${this.url}/reauthenticate`, {\r\n        headers: this.headers,\r\n        jwt: session.access_token,\r\n      })\r\n      return { data: { user: null, session: null }, error }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { user: null, session: null }, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Resends an existing signup confirmation email, email change email, SMS OTP or phone change OTP.\r\n   */\r\n  async resend(credentials: ResendParams): Promise<AuthResponse> {\r\n    try {\r\n      await this._removeSession()\r\n      const endpoint = `${this.url}/resend`\r\n      if ('email' in credentials) {\r\n        const { email, type, options } = credentials\r\n        const { error } = await _request(this.fetch, 'POST', endpoint, {\r\n          headers: this.headers,\r\n          body: {\r\n            email,\r\n            type,\r\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\r\n          },\r\n        })\r\n        return { data: { user: null, session: null }, error }\r\n      } else if ('phone' in credentials) {\r\n        const { phone, type, options } = credentials\r\n        const { error } = await _request(this.fetch, 'POST', endpoint, {\r\n          headers: this.headers,\r\n          body: {\r\n            phone,\r\n            type,\r\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\r\n          },\r\n        })\r\n        return { data: { user: null, session: null }, error }\r\n      }\r\n      throw new AuthInvalidCredentialsError(\r\n        'You must provide either an email or phone number and a type'\r\n      )\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { user: null, session: null }, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the session, refreshing it if necessary.\r\n   * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.\r\n   */\r\n  async getSession(): Promise<\r\n    | {\r\n        data: {\r\n          session: Session\r\n        }\r\n        error: null\r\n      }\r\n    | {\r\n        data: {\r\n          session: null\r\n        }\r\n        error: AuthError\r\n      }\r\n    | {\r\n        data: {\r\n          session: null\r\n        }\r\n        error: null\r\n      }\r\n  > {\r\n    // make sure we've read the session from the url if there is one\r\n    // save to just await, as long we make sure _initialize() never throws\r\n    await this.initializePromise\r\n\r\n    let currentSession: Session | null = null\r\n\r\n    if (this.persistSession) {\r\n      const maybeSession = await getItemAsync(this.storage, this.storageKey)\r\n\r\n      if (maybeSession !== null) {\r\n        if (this._isValidSession(maybeSession)) {\r\n          currentSession = maybeSession\r\n        } else {\r\n          await this._removeSession()\r\n        }\r\n      }\r\n    } else {\r\n      currentSession = this.inMemorySession\r\n    }\r\n\r\n    if (!currentSession) {\r\n      return { data: { session: null }, error: null }\r\n    }\r\n\r\n    const hasExpired = currentSession.expires_at\r\n      ? currentSession.expires_at <= Date.now() / 1000\r\n      : false\r\n    if (!hasExpired) {\r\n      return { data: { session: currentSession }, error: null }\r\n    }\r\n\r\n    const { session, error } = await this._callRefreshToken(currentSession.refresh_token)\r\n    if (error) {\r\n      return { data: { session: null }, error }\r\n    }\r\n\r\n    return { data: { session }, error: null }\r\n  }\r\n\r\n  /**\r\n   * Gets the current user details if there is an existing session.\r\n   * @param jwt Takes in an optional access token jwt. If no jwt is provided, getUser() will attempt to get the jwt from the current session.\r\n   */\r\n  async getUser(jwt?: string): Promise<UserResponse> {\r\n    try {\r\n      if (!jwt) {\r\n        const { data, error } = await this.getSession()\r\n        if (error) {\r\n          throw error\r\n        }\r\n\r\n        // Default to Authorization header if there is no existing session\r\n        jwt = data.session?.access_token ?? undefined\r\n      }\r\n\r\n      return await _request(this.fetch, 'GET', `${this.url}/user`, {\r\n        headers: this.headers,\r\n        jwt: jwt,\r\n        xform: _userResponse,\r\n      })\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { user: null }, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates user data for a logged in user.\r\n   */\r\n  async updateUser(\r\n    attributes: UserAttributes,\r\n    options: {\r\n      emailRedirectTo?: string | undefined\r\n    } = {}\r\n  ): Promise<UserResponse> {\r\n    try {\r\n      const { data: sessionData, error: sessionError } = await this.getSession()\r\n      if (sessionError) {\r\n        throw sessionError\r\n      }\r\n      if (!sessionData.session) {\r\n        throw new AuthSessionMissingError()\r\n      }\r\n      const session: Session = sessionData.session\r\n      const { data, error: userError } = await _request(this.fetch, 'PUT', `${this.url}/user`, {\r\n        headers: this.headers,\r\n        redirectTo: options?.emailRedirectTo,\r\n        body: attributes,\r\n        jwt: session.access_token,\r\n        xform: _userResponse,\r\n      })\r\n      if (userError) throw userError\r\n      session.user = data.user as User\r\n      await this._saveSession(session)\r\n      await this._notifyAllSubscribers('USER_UPDATED', session)\r\n\r\n      return { data: { user: session.user }, error: null }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { user: null }, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Decodes a JWT (without performing any validation).\r\n   */\r\n  private _decodeJWT(jwt: string): {\r\n    exp?: number\r\n    aal?: AuthenticatorAssuranceLevels | null\r\n    amr?: AMREntry[] | null\r\n  } {\r\n    return decodeJWTPayload(jwt)\r\n  }\r\n\r\n  /**\r\n   * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.\r\n   * If the refresh token or access token in the current session is invalid, an error will be thrown.\r\n   * @param currentSession The current session that minimally contains an access token and refresh token.\r\n   */\r\n  async setSession(currentSession: {\r\n    access_token: string\r\n    refresh_token: string\r\n  }): Promise<AuthResponse> {\r\n    try {\r\n      if (!currentSession.access_token || !currentSession.refresh_token) {\r\n        throw new AuthSessionMissingError()\r\n      }\r\n\r\n      const timeNow = Date.now() / 1000\r\n      let expiresAt = timeNow\r\n      let hasExpired = true\r\n      let session: Session | null = null\r\n      const payload = decodeJWTPayload(currentSession.access_token)\r\n      if (payload.exp) {\r\n        expiresAt = payload.exp\r\n        hasExpired = expiresAt <= timeNow\r\n      }\r\n\r\n      if (hasExpired) {\r\n        const { session: refreshedSession, error } = await this._callRefreshToken(\r\n          currentSession.refresh_token\r\n        )\r\n        if (error) {\r\n          return { data: { user: null, session: null }, error: error }\r\n        }\r\n\r\n        if (!refreshedSession) {\r\n          return { data: { user: null, session: null }, error: null }\r\n        }\r\n        session = refreshedSession\r\n      } else {\r\n        const { data, error } = await this.getUser(currentSession.access_token)\r\n        if (error) {\r\n          throw error\r\n        }\r\n        session = {\r\n          access_token: currentSession.access_token,\r\n          refresh_token: currentSession.refresh_token,\r\n          user: data.user,\r\n          token_type: 'bearer',\r\n          expires_in: expiresAt - timeNow,\r\n          expires_at: expiresAt,\r\n        }\r\n        await this._saveSession(session)\r\n        await this._notifyAllSubscribers('SIGNED_IN', session)\r\n      }\r\n\r\n      return { data: { user: session.user, session }, error: null }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { session: null, user: null }, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns a new session, regardless of expiry status.\r\n   * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().\r\n   * If the current session's refresh token is invalid, an error will be thrown.\r\n   * @param currentSession The current session. If passed in, it must contain a refresh token.\r\n   */\r\n  async refreshSession(currentSession?: { refresh_token: string }): Promise<AuthResponse> {\r\n    try {\r\n      if (!currentSession) {\r\n        const { data, error } = await this.getSession()\r\n        if (error) {\r\n          throw error\r\n        }\r\n\r\n        currentSession = data.session ?? undefined\r\n      }\r\n\r\n      if (!currentSession?.refresh_token) {\r\n        throw new AuthSessionMissingError()\r\n      }\r\n\r\n      const { session, error } = await this._callRefreshToken(currentSession.refresh_token)\r\n      if (error) {\r\n        return { data: { user: null, session: null }, error: error }\r\n      }\r\n\r\n      if (!session) {\r\n        return { data: { user: null, session: null }, error: null }\r\n      }\r\n\r\n      return { data: { user: session.user, session }, error: null }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { user: null, session: null }, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the session data from a URL string\r\n   */\r\n  private async _getSessionFromUrl(isPKCEFlow: boolean): Promise<\r\n    | {\r\n        data: { session: Session; redirectType: string | null }\r\n        error: null\r\n      }\r\n    | { data: { session: null; redirectType: null }; error: AuthError }\r\n  > {\r\n    try {\r\n      if (!isBrowser()) throw new AuthImplicitGrantRedirectError('No browser detected.')\r\n      if (this.flowType === 'implicit' && !this._isImplicitGrantFlow()) {\r\n        throw new AuthImplicitGrantRedirectError('Not a valid implicit grant flow url.')\r\n      } else if (this.flowType == 'pkce' && !isPKCEFlow) {\r\n        throw new AuthPKCEGrantCodeExchangeError('Not a valid PKCE flow url.')\r\n      }\r\n      if (isPKCEFlow) {\r\n        const authCode = getParameterByName('code')\r\n        if (!authCode) throw new AuthPKCEGrantCodeExchangeError('No code detected.')\r\n        const { data, error } = await this.exchangeCodeForSession(authCode)\r\n        if (error) throw error\r\n        if (!data.session) throw new AuthPKCEGrantCodeExchangeError('No session detected.')\r\n        let url = new URL(window.location.href)\r\n        url.searchParams.delete('code')\r\n        window.history.replaceState(window.history.state, '', url.toString())\r\n        return { data: { session: data.session, redirectType: null }, error: null }\r\n      }\r\n\r\n      const error_description = getParameterByName('error_description')\r\n      if (error_description) {\r\n        const error_code = getParameterByName('error_code')\r\n        if (!error_code) throw new AuthImplicitGrantRedirectError('No error_code detected.')\r\n        const error = getParameterByName('error')\r\n        if (!error) throw new AuthImplicitGrantRedirectError('No error detected.')\r\n\r\n        throw new AuthImplicitGrantRedirectError(error_description, { error, code: error_code })\r\n      }\r\n\r\n      const provider_token = getParameterByName('provider_token')\r\n      const provider_refresh_token = getParameterByName('provider_refresh_token')\r\n      const access_token = getParameterByName('access_token')\r\n      if (!access_token) throw new AuthImplicitGrantRedirectError('No access_token detected.')\r\n      const expires_in = getParameterByName('expires_in')\r\n      if (!expires_in) throw new AuthImplicitGrantRedirectError('No expires_in detected.')\r\n      const refresh_token = getParameterByName('refresh_token')\r\n      if (!refresh_token) throw new AuthImplicitGrantRedirectError('No refresh_token detected.')\r\n      const token_type = getParameterByName('token_type')\r\n      if (!token_type) throw new AuthImplicitGrantRedirectError('No token_type detected.')\r\n\r\n      const timeNow = Math.round(Date.now() / 1000)\r\n      const expires_at = timeNow + parseInt(expires_in)\r\n\r\n      const { data, error } = await this.getUser(access_token)\r\n      if (error) throw error\r\n      const user: User = data.user\r\n      const session: Session = {\r\n        provider_token,\r\n        provider_refresh_token,\r\n        access_token,\r\n        expires_in: parseInt(expires_in),\r\n        expires_at,\r\n        refresh_token,\r\n        token_type,\r\n        user,\r\n      }\r\n      const redirectType = getParameterByName('type')\r\n\r\n      // Remove tokens from URL\r\n      window.location.hash = ''\r\n\r\n      return { data: { session, redirectType }, error: null }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { session: null, redirectType: null }, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)\r\n   */\r\n  private _isImplicitGrantFlow(): boolean {\r\n    return (\r\n      isBrowser() &&\r\n      (Boolean(getParameterByName('access_token')) ||\r\n        Boolean(getParameterByName('error_description')))\r\n    )\r\n  }\r\n  /**\r\n   * Checks if the current URL and backing storage contain parameters given by a PKCE flow\r\n   */\r\n  private async _isPKCEFlow(): Promise<boolean> {\r\n    const currentStorageContent = await getItemAsync(\r\n      this.storage,\r\n      `${this.storageKey}-code-verifier`\r\n    )\r\n    return Boolean(getParameterByName('code')) && Boolean(currentStorageContent)\r\n  }\r\n\r\n  /**\r\n   * Inside a browser context, `signOut()` will remove the logged in user from the browser session\r\n   * and log them out - removing all items from localstorage and then trigger a `\"SIGNED_OUT\"` event.\r\n   *\r\n   * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.\r\n   * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.\r\n   */\r\n  async signOut(): Promise<{ error: AuthError | null }> {\r\n    const { data, error: sessionError } = await this.getSession()\r\n    if (sessionError) {\r\n      return { error: sessionError }\r\n    }\r\n    const accessToken = data.session?.access_token\r\n    if (accessToken) {\r\n      const { error } = await this.admin.signOut(accessToken)\r\n      if (error) {\r\n        // ignore 404s since user might not exist anymore\r\n        // ignore 401s since an invalid or expired JWT should sign out the current session\r\n        if (!(isAuthApiError(error) && (error.status === 404 || error.status === 401))) {\r\n          return { error }\r\n        }\r\n      }\r\n    }\r\n    await this._removeSession()\r\n    await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`)\r\n    await this._notifyAllSubscribers('SIGNED_OUT', null)\r\n    return { error: null }\r\n  }\r\n\r\n  /**\r\n   * Receive a notification every time an auth event happens.\r\n   * @param callback A callback function to be invoked when an auth event happens.\r\n   */\r\n  onAuthStateChange(\r\n    callback: (event: AuthChangeEvent, session: Session | null) => void | Promise<void>\r\n  ): {\r\n    data: { subscription: Subscription }\r\n  } {\r\n    const id: string = uuid()\r\n    const subscription: Subscription = {\r\n      id,\r\n      callback,\r\n      unsubscribe: () => {\r\n        this.stateChangeEmitters.delete(id)\r\n      },\r\n    }\r\n\r\n    this.stateChangeEmitters.set(id, subscription)\r\n\r\n    this.emitInitialSession(id)\r\n\r\n    return { data: { subscription } }\r\n  }\r\n\r\n  private async emitInitialSession(id: string): Promise<void> {\r\n    try {\r\n      const {\r\n        data: { session },\r\n        error,\r\n      } = await this.getSession()\r\n      if (error) throw error\r\n\r\n      await this.stateChangeEmitters.get(id)?.callback('INITIAL_SESSION', session)\r\n    } catch (err) {\r\n      await this.stateChangeEmitters.get(id)?.callback('INITIAL_SESSION', null)\r\n      console.error(err)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sends a password reset request to an email address.\r\n   * This method supports the PKCE flow.\r\n   * @param email The email address of the user.\r\n   * @param options.redirectTo The URL to send the user to after they click the password reset link.\r\n   * @param options.captchaToken Verification token received when the user completes the captcha on the site.\r\n   */\r\n  async resetPasswordForEmail(\r\n    email: string,\r\n    options: {\r\n      redirectTo?: string\r\n      captchaToken?: string\r\n    } = {}\r\n  ): Promise<\r\n    | {\r\n        data: {}\r\n        error: null\r\n      }\r\n    | { data: null; error: AuthError }\r\n  > {\r\n    let codeChallenge: string | null = null\r\n    let codeChallengeMethod: string | null = null\r\n    if (this.flowType === 'pkce') {\r\n      const codeVerifier = generatePKCEVerifier()\r\n      await setItemAsync(this.storage, `${this.storageKey}-code-verifier`, codeVerifier)\r\n      codeChallenge = await generatePKCEChallenge(codeVerifier)\r\n      codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256'\r\n    }\r\n    try {\r\n      return await _request(this.fetch, 'POST', `${this.url}/recover`, {\r\n        body: {\r\n          email,\r\n          code_challenge: codeChallenge,\r\n          code_challenge_method: codeChallengeMethod,\r\n          gotrue_meta_security: { captcha_token: options.captchaToken },\r\n        },\r\n        headers: this.headers,\r\n        redirectTo: options.redirectTo,\r\n      })\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: null, error }\r\n      }\r\n\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generates a new JWT.\r\n   * @param refreshToken A valid refresh token that was returned on login.\r\n   */\r\n  private async _refreshAccessToken(refreshToken: string): Promise<AuthResponse> {\r\n    try {\r\n      const startedAt = Date.now()\r\n\r\n      // will attempt to refresh the token with exponential backoff\r\n      return await retryable(\r\n        async (attempt) => {\r\n          await sleep(attempt * 200) // 0, 200, 400, 800, ...\r\n\r\n          return await _request(this.fetch, 'POST', `${this.url}/token?grant_type=refresh_token`, {\r\n            body: { refresh_token: refreshToken },\r\n            headers: this.headers,\r\n            xform: _sessionResponse,\r\n          })\r\n        },\r\n        (attempt, _, result) =>\r\n          result &&\r\n          result.error &&\r\n          result.error instanceof AuthRetryableFetchError &&\r\n          // retryable only if the request can be sent before the backoff overflows the tick duration\r\n          Date.now() + (attempt + 1) * 200 - startedAt < AUTO_REFRESH_TICK_DURATION\r\n      )\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: { session: null, user: null }, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  private _isValidSession(maybeSession: unknown): maybeSession is Session {\r\n    const isValidSession =\r\n      typeof maybeSession === 'object' &&\r\n      maybeSession !== null &&\r\n      'access_token' in maybeSession &&\r\n      'refresh_token' in maybeSession &&\r\n      'expires_at' in maybeSession\r\n\r\n    return isValidSession\r\n  }\r\n\r\n  private async _handleProviderSignIn(\r\n    provider: Provider,\r\n    options: {\r\n      redirectTo?: string\r\n      scopes?: string\r\n      queryParams?: { [key: string]: string }\r\n      skipBrowserRedirect?: boolean\r\n    }\r\n  ) {\r\n    const url: string = await this._getUrlForProvider(provider, {\r\n      redirectTo: options.redirectTo,\r\n      scopes: options.scopes,\r\n      queryParams: options.queryParams,\r\n    })\r\n    // try to open on the browser\r\n    if (isBrowser() && !options.skipBrowserRedirect) {\r\n      window.location.assign(url)\r\n    }\r\n\r\n    return { data: { provider, url }, error: null }\r\n  }\r\n\r\n  /**\r\n   * Recovers the session from LocalStorage and refreshes\r\n   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\r\n   */\r\n  private async _recoverAndRefresh() {\r\n    try {\r\n      const currentSession = await getItemAsync(this.storage, this.storageKey)\r\n      if (!this._isValidSession(currentSession)) {\r\n        if (currentSession !== null) {\r\n          await this._removeSession()\r\n        }\r\n\r\n        return\r\n      }\r\n\r\n      const timeNow = Math.round(Date.now() / 1000)\r\n\r\n      if ((currentSession.expires_at ?? Infinity) < timeNow + EXPIRY_MARGIN) {\r\n        if (this.autoRefreshToken && currentSession.refresh_token) {\r\n          const { error } = await this._callRefreshToken(currentSession.refresh_token)\r\n\r\n          if (error) {\r\n            console.log(error.message)\r\n            await this._removeSession()\r\n          }\r\n        }\r\n      } else {\r\n        if (this.persistSession) {\r\n          await this._saveSession(currentSession)\r\n        }\r\n        await this._notifyAllSubscribers('SIGNED_IN', currentSession)\r\n      }\r\n    } catch (err) {\r\n      console.error(err)\r\n      return\r\n    }\r\n  }\r\n\r\n  private async _callRefreshToken(refreshToken: string): Promise<CallRefreshTokenResult> {\r\n    // refreshing is already in progress\r\n    if (this.refreshingDeferred) {\r\n      return this.refreshingDeferred.promise\r\n    }\r\n\r\n    try {\r\n      this.refreshingDeferred = new Deferred<CallRefreshTokenResult>()\r\n\r\n      if (!refreshToken) {\r\n        throw new AuthSessionMissingError()\r\n      }\r\n      const { data, error } = await this._refreshAccessToken(refreshToken)\r\n      if (error) throw error\r\n      if (!data.session) throw new AuthSessionMissingError()\r\n\r\n      await this._saveSession(data.session)\r\n      await this._notifyAllSubscribers('TOKEN_REFRESHED', data.session)\r\n\r\n      const result = { session: data.session, error: null }\r\n\r\n      this.refreshingDeferred.resolve(result)\r\n\r\n      return result\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        const result = { session: null, error }\r\n\r\n        this.refreshingDeferred?.resolve(result)\r\n\r\n        return result\r\n      }\r\n\r\n      this.refreshingDeferred?.reject(error)\r\n      throw error\r\n    } finally {\r\n      this.refreshingDeferred = null\r\n    }\r\n  }\r\n\r\n  private async _notifyAllSubscribers(\r\n    event: AuthChangeEvent,\r\n    session: Session | null,\r\n    broadcast = true\r\n  ) {\r\n    if (this.broadcastChannel && broadcast) {\r\n      this.broadcastChannel.postMessage({ event, session })\r\n    }\r\n\r\n    const errors: any[] = []\r\n    const promises = Array.from(this.stateChangeEmitters.values()).map(async (x) => {\r\n      try {\r\n        await x.callback(event, session)\r\n      } catch (e: any) {\r\n        errors.push(e)\r\n      }\r\n    })\r\n\r\n    await Promise.all(promises)\r\n\r\n    if (errors.length > 0) {\r\n      for (let i = 0; i < errors.length; i += 1) {\r\n        console.error(errors[i])\r\n      }\r\n\r\n      throw errors[0]\r\n    }\r\n  }\r\n\r\n  /**\r\n   * set currentSession and currentUser\r\n   * process to _startAutoRefreshToken if possible\r\n   */\r\n  private async _saveSession(session: Session) {\r\n    if (!this.persistSession) {\r\n      this.inMemorySession = session\r\n    }\r\n\r\n    if (this.persistSession && session.expires_at) {\r\n      await this._persistSession(session)\r\n    }\r\n  }\r\n\r\n  private _persistSession(currentSession: Session) {\r\n    return setItemAsync(this.storage, this.storageKey, currentSession)\r\n  }\r\n\r\n  private async _removeSession() {\r\n    if (this.persistSession) {\r\n      await removeItemAsync(this.storage, this.storageKey)\r\n    } else {\r\n      this.inMemorySession = null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes any registered visibilitychange callback.\r\n   *\r\n   * {@see #startAutoRefresh}\r\n   * {@see #stopAutoRefresh}\r\n   */\r\n  private _removeVisibilityChangedCallback() {\r\n    const callback = this.visibilityChangedCallback\r\n    this.visibilityChangedCallback = null\r\n\r\n    try {\r\n      if (callback && isBrowser() && window?.removeEventListener) {\r\n        window.removeEventListener('visibilitychange', callback)\r\n      }\r\n    } catch (e) {\r\n      console.error('removing visibilitychange callback failed', e)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This is the private implementation of {@link #startAutoRefresh}. Use this\r\n   * within the library.\r\n   */\r\n  private async _startAutoRefresh() {\r\n    await this._stopAutoRefresh()\r\n\r\n    const ticker = setInterval(() => this._autoRefreshTokenTick(), AUTO_REFRESH_TICK_DURATION)\r\n    this.autoRefreshTicker = ticker\r\n\r\n    if (ticker && typeof ticker === 'object' && typeof ticker.unref === 'function') {\r\n      // ticker is a NodeJS Timeout object that has an `unref` method\r\n      // https://nodejs.org/api/timers.html#timeoutunref\r\n      // When auto refresh is used in NodeJS (like for testing) the\r\n      // `setInterval` is preventing the process from being marked as\r\n      // finished and tests run endlessly. This can be prevented by calling\r\n      // `unref()` on the returned object.\r\n      ticker.unref()\r\n      // @ts-ignore\r\n    } else if (typeof Deno !== 'undefined' && typeof Deno.unrefTimer === 'function') {\r\n      // similar like for NodeJS, but with the Deno API\r\n      // https://deno.land/api@latest?unstable&s=Deno.unrefTimer\r\n      // @ts-ignore\r\n      Deno.unrefTimer(ticker)\r\n    }\r\n\r\n    // run the tick immediately\r\n    await this._autoRefreshTokenTick()\r\n  }\r\n\r\n  /**\r\n   * This is the private implementation of {@link #stopAutoRefresh}. Use this\r\n   * within the library.\r\n   */\r\n  private async _stopAutoRefresh() {\r\n    const ticker = this.autoRefreshTicker\r\n    this.autoRefreshTicker = null\r\n\r\n    if (ticker) {\r\n      clearInterval(ticker)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Starts an auto-refresh process in the background. The session is checked\r\n   * every few seconds. Close to the time of expiration a process is started to\r\n   * refresh the session. If refreshing fails it will be retried for as long as\r\n   * necessary.\r\n   *\r\n   * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need\r\n   * to call this function, it will be called for you.\r\n   *\r\n   * On browsers the refresh process works only when the tab/window is in the\r\n   * foreground to conserve resources as well as prevent race conditions and\r\n   * flooding auth with requests. If you call this method any managed\r\n   * visibility change callback will be removed and you must manage visibility\r\n   * changes on your own.\r\n   *\r\n   * On non-browser platforms the refresh process works *continuously* in the\r\n   * background, which may not be desirable. You should hook into your\r\n   * platform's foreground indication mechanism and call these methods\r\n   * appropriately to conserve resources.\r\n   *\r\n   * {@see #stopAutoRefresh}\r\n   */\r\n  async startAutoRefresh() {\r\n    this._removeVisibilityChangedCallback()\r\n    await this._startAutoRefresh()\r\n  }\r\n\r\n  /**\r\n   * Stops an active auto refresh process running in the background (if any).\r\n   *\r\n   * If you call this method any managed visibility change callback will be\r\n   * removed and you must manage visibility changes on your own.\r\n   *\r\n   * See {@link #startAutoRefresh} for more details.\r\n   */\r\n  async stopAutoRefresh() {\r\n    this._removeVisibilityChangedCallback()\r\n    await this._stopAutoRefresh()\r\n  }\r\n\r\n  /**\r\n   * Runs the auto refresh token tick.\r\n   */\r\n  private async _autoRefreshTokenTick() {\r\n    const now = Date.now()\r\n\r\n    try {\r\n      const {\r\n        data: { session },\r\n      } = await this.getSession()\r\n\r\n      if (!session || !session.refresh_token || !session.expires_at) {\r\n        return\r\n      }\r\n\r\n      // session will expire in this many ticks (or has already expired if <= 0)\r\n      const expiresInTicks = Math.floor(\r\n        (session.expires_at * 1000 - now) / AUTO_REFRESH_TICK_DURATION\r\n      )\r\n\r\n      if (expiresInTicks < AUTO_REFRESH_TICK_THRESHOLD) {\r\n        await this._callRefreshToken(session.refresh_token)\r\n      }\r\n    } catch (e: any) {\r\n      console.error('Auto refresh tick failed with error. This is likely a transient error.', e)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Registers callbacks on the browser / platform, which in-turn run\r\n   * algorithms when the browser window/tab are in foreground. On non-browser\r\n   * platforms it assumes always foreground.\r\n   */\r\n  private async _handleVisibilityChange() {\r\n    if (!isBrowser() || !window?.addEventListener) {\r\n      if (this.autoRefreshToken) {\r\n        // in non-browser environments the refresh token ticker runs always\r\n        this.startAutoRefresh()\r\n      }\r\n\r\n      return false\r\n    }\r\n\r\n    try {\r\n      this.visibilityChangedCallback = async () => await this._onVisibilityChanged(false)\r\n\r\n      window?.addEventListener('visibilitychange', this.visibilityChangedCallback)\r\n\r\n      // now immediately call the visbility changed callback to setup with the\r\n      // current visbility state\r\n      await this._onVisibilityChanged(true) // initial call\r\n    } catch (error) {\r\n      console.error('_handleVisibilityChange', error)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Callback registered with `window.addEventListener('visibilitychange')`.\r\n   */\r\n  private async _onVisibilityChanged(isInitial: boolean) {\r\n    if (document.visibilityState === 'visible') {\r\n      if (!isInitial) {\r\n        // initial visibility change setup is handled in another flow under #initialize()\r\n        await this.initializePromise\r\n        await this._recoverAndRefresh()\r\n      }\r\n\r\n      if (this.autoRefreshToken) {\r\n        // in browser environments the refresh token ticker runs only on focused tabs\r\n        // which prevents race conditions\r\n        this._startAutoRefresh()\r\n      }\r\n    } else if (document.visibilityState === 'hidden') {\r\n      if (this.autoRefreshToken) {\r\n        this._stopAutoRefresh()\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generates the relevant login URL for a third-party provider.\r\n   * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.\r\n   * @param options.scopes A space-separated list of scopes granted to the OAuth application.\r\n   * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.\r\n   */\r\n  private async _getUrlForProvider(\r\n    provider: Provider,\r\n    options: {\r\n      redirectTo?: string\r\n      scopes?: string\r\n      queryParams?: { [key: string]: string }\r\n    }\r\n  ) {\r\n    const urlParams: string[] = [`provider=${encodeURIComponent(provider)}`]\r\n    if (options?.redirectTo) {\r\n      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`)\r\n    }\r\n    if (options?.scopes) {\r\n      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`)\r\n    }\r\n    if (this.flowType === 'pkce') {\r\n      const codeVerifier = generatePKCEVerifier()\r\n      await setItemAsync(this.storage, `${this.storageKey}-code-verifier`, codeVerifier)\r\n      const codeChallenge = await generatePKCEChallenge(codeVerifier)\r\n      const codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256'\r\n      const flowParams = new URLSearchParams({\r\n        code_challenge: `${encodeURIComponent(codeChallenge)}`,\r\n        code_challenge_method: `${encodeURIComponent(codeChallengeMethod)}`,\r\n      })\r\n      urlParams.push(flowParams.toString())\r\n    }\r\n    if (options?.queryParams) {\r\n      const query = new URLSearchParams(options.queryParams)\r\n      urlParams.push(query.toString())\r\n    }\r\n\r\n    return `${this.url}/authorize?${urlParams.join('&')}`\r\n  }\r\n\r\n  private async _unenroll(params: MFAUnenrollParams): Promise<AuthMFAUnenrollResponse> {\r\n    try {\r\n      const { data: sessionData, error: sessionError } = await this.getSession()\r\n      if (sessionError) {\r\n        return { data: null, error: sessionError }\r\n      }\r\n\r\n      return await _request(this.fetch, 'DELETE', `${this.url}/factors/${params.factorId}`, {\r\n        headers: this.headers,\r\n        jwt: sessionData?.session?.access_token,\r\n      })\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: null, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * {@see GoTrueMFAApi#enroll}\r\n   */\r\n  private async _enroll(params: MFAEnrollParams): Promise<AuthMFAEnrollResponse> {\r\n    try {\r\n      const { data: sessionData, error: sessionError } = await this.getSession()\r\n      if (sessionError) {\r\n        return { data: null, error: sessionError }\r\n      }\r\n\r\n      const { data, error } = await _request(this.fetch, 'POST', `${this.url}/factors`, {\r\n        body: {\r\n          friendly_name: params.friendlyName,\r\n          factor_type: params.factorType,\r\n          issuer: params.issuer,\r\n        },\r\n        headers: this.headers,\r\n        jwt: sessionData?.session?.access_token,\r\n      })\r\n\r\n      if (error) {\r\n        return { data: null, error }\r\n      }\r\n\r\n      if (data?.totp?.qr_code) {\r\n        data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`\r\n      }\r\n\r\n      return { data, error: null }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: null, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * {@see GoTrueMFAApi#verify}\r\n   */\r\n  private async _verify(params: MFAVerifyParams): Promise<AuthMFAVerifyResponse> {\r\n    try {\r\n      const { data: sessionData, error: sessionError } = await this.getSession()\r\n      if (sessionError) {\r\n        return { data: null, error: sessionError }\r\n      }\r\n\r\n      const { data, error } = await _request(\r\n        this.fetch,\r\n        'POST',\r\n        `${this.url}/factors/${params.factorId}/verify`,\r\n        {\r\n          body: { code: params.code, challenge_id: params.challengeId },\r\n          headers: this.headers,\r\n          jwt: sessionData?.session?.access_token,\r\n        }\r\n      )\r\n      if (error) {\r\n        return { data: null, error }\r\n      }\r\n\r\n      await this._saveSession({\r\n        expires_at: Math.round(Date.now() / 1000) + data.expires_in,\r\n        ...data,\r\n      })\r\n      await this._notifyAllSubscribers('MFA_CHALLENGE_VERIFIED', data)\r\n\r\n      return { data, error }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: null, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * {@see GoTrueMFAApi#challenge}\r\n   */\r\n  private async _challenge(params: MFAChallengeParams): Promise<AuthMFAChallengeResponse> {\r\n    try {\r\n      const { data: sessionData, error: sessionError } = await this.getSession()\r\n      if (sessionError) {\r\n        return { data: null, error: sessionError }\r\n      }\r\n\r\n      return await _request(\r\n        this.fetch,\r\n        'POST',\r\n        `${this.url}/factors/${params.factorId}/challenge`,\r\n        {\r\n          headers: this.headers,\r\n          jwt: sessionData?.session?.access_token,\r\n        }\r\n      )\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: null, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * {@see GoTrueMFAApi#challengeAndVerify}\r\n   */\r\n  private async _challengeAndVerify(\r\n    params: MFAChallengeAndVerifyParams\r\n  ): Promise<AuthMFAVerifyResponse> {\r\n    const { data: challengeData, error: challengeError } = await this._challenge({\r\n      factorId: params.factorId,\r\n    })\r\n    if (challengeError) {\r\n      return { data: null, error: challengeError }\r\n    }\r\n    return await this._verify({\r\n      factorId: params.factorId,\r\n      challengeId: challengeData.id,\r\n      code: params.code,\r\n    })\r\n  }\r\n\r\n  /**\r\n   * {@see GoTrueMFAApi#listFactors}\r\n   */\r\n  private async _listFactors(): Promise<AuthMFAListFactorsResponse> {\r\n    const {\r\n      data: { user },\r\n      error: userError,\r\n    } = await this.getUser()\r\n    if (userError) {\r\n      return { data: null, error: userError }\r\n    }\r\n\r\n    const factors = user?.factors || []\r\n    const totp = factors.filter(\r\n      (factor) => factor.factor_type === 'totp' && factor.status === 'verified'\r\n    )\r\n\r\n    return {\r\n      data: {\r\n        all: factors,\r\n        totp,\r\n      },\r\n      error: null,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}\r\n   */\r\n  private async _getAuthenticatorAssuranceLevel(): Promise<AuthMFAGetAuthenticatorAssuranceLevelResponse> {\r\n    const {\r\n      data: { session },\r\n      error: sessionError,\r\n    } = await this.getSession()\r\n    if (sessionError) {\r\n      return { data: null, error: sessionError }\r\n    }\r\n    if (!session) {\r\n      return {\r\n        data: { currentLevel: null, nextLevel: null, currentAuthenticationMethods: [] },\r\n        error: null,\r\n      }\r\n    }\r\n\r\n    const payload = this._decodeJWT(session.access_token)\r\n\r\n    let currentLevel: AuthenticatorAssuranceLevels | null = null\r\n\r\n    if (payload.aal) {\r\n      currentLevel = payload.aal\r\n    }\r\n\r\n    let nextLevel: AuthenticatorAssuranceLevels | null = currentLevel\r\n\r\n    const verifiedFactors =\r\n      session.user.factors?.filter((factor: Factor) => factor.status === 'verified') ?? []\r\n\r\n    if (verifiedFactors.length > 0) {\r\n      nextLevel = 'aal2'\r\n    }\r\n\r\n    const currentAuthenticationMethods = payload.amr || []\r\n\r\n    return { data: { currentLevel, nextLevel, currentAuthenticationMethods }, error: null }\r\n  }\r\n}\r\n"],
  "mappings": "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",
  "names": ["__awaiter", "fetch", "__rest", "__awaiter", "expiresAt", "error", "data"]
}
