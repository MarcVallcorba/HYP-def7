{
  "version": 3,
  "sources": ["../../@supabase/postgrest-js/src/PostgrestBuilder.ts", "../../@supabase/postgrest-js/src/PostgrestTransformBuilder.ts", "../../@supabase/postgrest-js/src/PostgrestFilterBuilder.ts", "../../@supabase/postgrest-js/src/PostgrestQueryBuilder.ts", "../../@supabase/postgrest-js/src/version.ts", "../../@supabase/postgrest-js/src/constants.ts", "../../@supabase/postgrest-js/src/PostgrestClient.ts"],
  "sourcesContent": ["import crossFetch from 'cross-fetch'\r\n\r\nimport type { Fetch, PostgrestSingleResponse } from './types'\r\n\r\nexport default abstract class PostgrestBuilder<Result>\r\n  implements PromiseLike<PostgrestSingleResponse<Result>>\r\n{\r\n  protected method: 'GET' | 'HEAD' | 'POST' | 'PATCH' | 'DELETE'\r\n  protected url: URL\r\n  protected headers: Record<string, string>\r\n  protected schema?: string\r\n  protected body?: unknown\r\n  protected shouldThrowOnError = false\r\n  protected signal?: AbortSignal\r\n  protected fetch: Fetch\r\n  protected isMaybeSingle: boolean\r\n\r\n  constructor(builder: PostgrestBuilder<Result>) {\r\n    this.method = builder.method\r\n    this.url = builder.url\r\n    this.headers = builder.headers\r\n    this.schema = builder.schema\r\n    this.body = builder.body\r\n    this.shouldThrowOnError = builder.shouldThrowOnError\r\n    this.signal = builder.signal\r\n    this.isMaybeSingle = builder.isMaybeSingle\r\n\r\n    if (builder.fetch) {\r\n      this.fetch = builder.fetch\r\n    } else if (typeof fetch === 'undefined') {\r\n      this.fetch = crossFetch\r\n    } else {\r\n      this.fetch = fetch\r\n    }\r\n  }\r\n\r\n  /**\r\n   * If there's an error with the query, throwOnError will reject the promise by\r\n   * throwing the error instead of returning it as part of a successful response.\r\n   *\r\n   * {@link https://github.com/supabase/supabase-js/issues/92}\r\n   */\r\n  throwOnError(): this {\r\n    this.shouldThrowOnError = true\r\n    return this\r\n  }\r\n\r\n  then<TResult1 = PostgrestSingleResponse<Result>, TResult2 = never>(\r\n    onfulfilled?:\r\n      | ((value: PostgrestSingleResponse<Result>) => TResult1 | PromiseLike<TResult1>)\r\n      | undefined\r\n      | null,\r\n    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null\r\n  ): PromiseLike<TResult1 | TResult2> {\r\n    // https://postgrest.org/en/stable/api.html#switching-schemas\r\n    if (this.schema === undefined) {\r\n      // skip\r\n    } else if (['GET', 'HEAD'].includes(this.method)) {\r\n      this.headers['Accept-Profile'] = this.schema\r\n    } else {\r\n      this.headers['Content-Profile'] = this.schema\r\n    }\r\n    if (this.method !== 'GET' && this.method !== 'HEAD') {\r\n      this.headers['Content-Type'] = 'application/json'\r\n    }\r\n\r\n    // NOTE: Invoke w/o `this` to avoid illegal invocation error.\r\n    // https://github.com/supabase/postgrest-js/pull/247\r\n    const _fetch = this.fetch\r\n    let res = _fetch(this.url.toString(), {\r\n      method: this.method,\r\n      headers: this.headers,\r\n      body: JSON.stringify(this.body),\r\n      signal: this.signal,\r\n    }).then(async (res) => {\r\n      let error = null\r\n      let data = null\r\n      let count: number | null = null\r\n      let status = res.status\r\n      let statusText = res.statusText\r\n\r\n      if (res.ok) {\r\n        if (this.method !== 'HEAD') {\r\n          const body = await res.text()\r\n          if (body === '') {\r\n            // Prefer: return=minimal\r\n          } else if (this.headers['Accept'] === 'text/csv') {\r\n            data = body\r\n          } else if (\r\n            this.headers['Accept'] &&\r\n            this.headers['Accept'].includes('application/vnd.pgrst.plan+text')\r\n          ) {\r\n            data = body\r\n          } else {\r\n            data = JSON.parse(body)\r\n          }\r\n        }\r\n\r\n        const countHeader = this.headers['Prefer']?.match(/count=(exact|planned|estimated)/)\r\n        const contentRange = res.headers.get('content-range')?.split('/')\r\n        if (countHeader && contentRange && contentRange.length > 1) {\r\n          count = parseInt(contentRange[1])\r\n        }\r\n\r\n        // Temporary partial fix for https://github.com/supabase/postgrest-js/issues/361\r\n        // Issue persists e.g. for `.insert([...]).select().maybeSingle()`\r\n        if (this.isMaybeSingle && this.method === 'GET' && Array.isArray(data)) {\r\n          if (data.length > 1) {\r\n            error = {\r\n              // https://github.com/PostgREST/postgrest/blob/a867d79c42419af16c18c3fb019eba8df992626f/src/PostgREST/Error.hs#L553\r\n              code: 'PGRST116',\r\n              details: `Results contain ${data.length} rows, application/vnd.pgrst.object+json requires 1 row`,\r\n              hint: null,\r\n              message: 'JSON object requested, multiple (or no) rows returned',\r\n            }\r\n            data = null\r\n            count = null\r\n            status = 406\r\n            statusText = 'Not Acceptable'\r\n          } else if (data.length === 1) {\r\n            data = data[0]\r\n          } else {\r\n            data = null\r\n          }\r\n        }\r\n      } else {\r\n        const body = await res.text()\r\n\r\n        try {\r\n          error = JSON.parse(body)\r\n\r\n          // Workaround for https://github.com/supabase/postgrest-js/issues/295\r\n          if (Array.isArray(error) && res.status === 404) {\r\n            data = []\r\n            error = null\r\n            status = 200\r\n            statusText = 'OK'\r\n          }\r\n        } catch {\r\n          // Workaround for https://github.com/supabase/postgrest-js/issues/295\r\n          if (res.status === 404 && body === '') {\r\n            status = 204\r\n            statusText = 'No Content'\r\n          } else {\r\n            error = {\r\n              message: body,\r\n            }\r\n          }\r\n        }\r\n\r\n        if (error && this.isMaybeSingle && error?.details?.includes('Results contain 0 rows')) {\r\n          error = null\r\n          status = 200\r\n          statusText = 'OK'\r\n        }\r\n\r\n        if (error && this.shouldThrowOnError) {\r\n          throw error\r\n        }\r\n      }\r\n\r\n      const postgrestResponse = {\r\n        error,\r\n        data,\r\n        count,\r\n        status,\r\n        statusText,\r\n      }\r\n\r\n      return postgrestResponse\r\n    })\r\n    if (!this.shouldThrowOnError) {\r\n      res = res.catch((fetchError) => ({\r\n        error: {\r\n          message: `${fetchError?.name ?? 'FetchError'}: ${fetchError?.message}`,\r\n          details: `${fetchError?.stack ?? ''}`,\r\n          hint: '',\r\n          code: `${fetchError?.code ?? ''}`,\r\n        },\r\n        data: null,\r\n        count: null,\r\n        status: 0,\r\n        statusText: '',\r\n      }))\r\n    }\r\n\r\n    return res.then(onfulfilled, onrejected)\r\n  }\r\n}\r\n", "import PostgrestBuilder from './PostgrestBuilder'\r\nimport { GetResult } from './select-query-parser'\r\nimport { GenericSchema } from './types'\r\n\r\nexport default class PostgrestTransformBuilder<\r\n  Schema extends GenericSchema,\r\n  Row extends Record<string, unknown>,\r\n  Result,\r\n  Relationships = unknown\r\n> extends PostgrestBuilder<Result> {\r\n  /**\r\n   * Perform a SELECT on the query result.\r\n   *\r\n   * By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not\r\n   * return modified rows. By calling this method, modified rows are returned in\r\n   * `data`.\r\n   *\r\n   * @param columns - The columns to retrieve, separated by commas\r\n   */\r\n  select<Query extends string = '*', NewResultOne = GetResult<Schema, Row, Relationships, Query>>(\r\n    columns?: Query\r\n  ): PostgrestTransformBuilder<Schema, Row, NewResultOne[], Relationships> {\r\n    // Remove whitespaces except when quoted\r\n    let quoted = false\r\n    const cleanedColumns = (columns ?? '*')\r\n      .split('')\r\n      .map((c) => {\r\n        if (/\\s/.test(c) && !quoted) {\r\n          return ''\r\n        }\r\n        if (c === '\"') {\r\n          quoted = !quoted\r\n        }\r\n        return c\r\n      })\r\n      .join('')\r\n    this.url.searchParams.set('select', cleanedColumns)\r\n    if (this.headers['Prefer']) {\r\n      this.headers['Prefer'] += ','\r\n    }\r\n    this.headers['Prefer'] += 'return=representation'\r\n    return this as unknown as PostgrestTransformBuilder<Schema, Row, NewResultOne[], Relationships>\r\n  }\r\n\r\n  order<ColumnName extends string & keyof Row>(\r\n    column: ColumnName,\r\n    options?: { ascending?: boolean; nullsFirst?: boolean; foreignTable?: undefined }\r\n  ): this\r\n  order(\r\n    column: string,\r\n    options?: { ascending?: boolean; nullsFirst?: boolean; foreignTable: string }\r\n  ): this\r\n  /**\r\n   * Order the query result by `column`.\r\n   *\r\n   * You can call this method multiple times to order by multiple columns.\r\n   *\r\n   * You can order foreign tables, but it doesn't affect the ordering of the\r\n   * current table.\r\n   *\r\n   * @param column - The column to order by\r\n   * @param options - Named parameters\r\n   * @param options.ascending - If `true`, the result will be in ascending order\r\n   * @param options.nullsFirst - If `true`, `null`s appear first. If `false`,\r\n   * `null`s appear last.\r\n   * @param options.foreignTable - Set this to order a foreign table by foreign\r\n   * columns\r\n   */\r\n  order(\r\n    column: string,\r\n    {\r\n      ascending = true,\r\n      nullsFirst,\r\n      foreignTable,\r\n    }: { ascending?: boolean; nullsFirst?: boolean; foreignTable?: string } = {}\r\n  ): this {\r\n    const key = foreignTable ? `${foreignTable}.order` : 'order'\r\n    const existingOrder = this.url.searchParams.get(key)\r\n\r\n    this.url.searchParams.set(\r\n      key,\r\n      `${existingOrder ? `${existingOrder},` : ''}${column}.${ascending ? 'asc' : 'desc'}${\r\n        nullsFirst === undefined ? '' : nullsFirst ? '.nullsfirst' : '.nullslast'\r\n      }`\r\n    )\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Limit the query result by `count`.\r\n   *\r\n   * @param count - The maximum number of rows to return\r\n   * @param options - Named parameters\r\n   * @param options.foreignTable - Set this to limit rows of foreign tables\r\n   * instead of the current table\r\n   */\r\n  limit(count: number, { foreignTable }: { foreignTable?: string } = {}): this {\r\n    const key = typeof foreignTable === 'undefined' ? 'limit' : `${foreignTable}.limit`\r\n    this.url.searchParams.set(key, `${count}`)\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Limit the query result by `from` and `to` inclusively.\r\n   *\r\n   * @param from - The starting index from which to limit the result\r\n   * @param to - The last index to which to limit the result\r\n   * @param options - Named parameters\r\n   * @param options.foreignTable - Set this to limit rows of foreign tables\r\n   * instead of the current table\r\n   */\r\n  range(from: number, to: number, { foreignTable }: { foreignTable?: string } = {}): this {\r\n    const keyOffset = typeof foreignTable === 'undefined' ? 'offset' : `${foreignTable}.offset`\r\n    const keyLimit = typeof foreignTable === 'undefined' ? 'limit' : `${foreignTable}.limit`\r\n    this.url.searchParams.set(keyOffset, `${from}`)\r\n    // Range is inclusive, so add 1\r\n    this.url.searchParams.set(keyLimit, `${to - from + 1}`)\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Set the AbortSignal for the fetch request.\r\n   *\r\n   * @param signal - The AbortSignal to use for the fetch request\r\n   */\r\n  abortSignal(signal: AbortSignal): this {\r\n    this.signal = signal\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Return `data` as a single object instead of an array of objects.\r\n   *\r\n   * Query result must be one row (e.g. using `.limit(1)`), otherwise this\r\n   * returns an error.\r\n   */\r\n  single<\r\n    ResultOne = Result extends (infer ResultOne)[] ? ResultOne : never\r\n  >(): PostgrestBuilder<ResultOne> {\r\n    this.headers['Accept'] = 'application/vnd.pgrst.object+json'\r\n    return this as PostgrestBuilder<ResultOne>\r\n  }\r\n\r\n  /**\r\n   * Return `data` as a single object instead of an array of objects.\r\n   *\r\n   * Query result must be zero or one row (e.g. using `.limit(1)`), otherwise\r\n   * this returns an error.\r\n   */\r\n  maybeSingle<\r\n    ResultOne = Result extends (infer ResultOne)[] ? ResultOne : never\r\n  >(): PostgrestBuilder<ResultOne | null> {\r\n    // Temporary partial fix for https://github.com/supabase/postgrest-js/issues/361\r\n    // Issue persists e.g. for `.insert([...]).select().maybeSingle()`\r\n    if (this.method === 'GET') {\r\n      this.headers['Accept'] = 'application/json'\r\n    } else {\r\n      this.headers['Accept'] = 'application/vnd.pgrst.object+json'\r\n    }\r\n    this.isMaybeSingle = true\r\n    return this as PostgrestBuilder<ResultOne | null>\r\n  }\r\n\r\n  /**\r\n   * Return `data` as a string in CSV format.\r\n   */\r\n  csv(): PostgrestBuilder<string> {\r\n    this.headers['Accept'] = 'text/csv'\r\n    return this as PostgrestBuilder<string>\r\n  }\r\n\r\n  /**\r\n   * Return `data` as an object in [GeoJSON](https://geojson.org) format.\r\n   */\r\n  geojson(): PostgrestBuilder<Record<string, unknown>> {\r\n    this.headers['Accept'] = 'application/geo+json'\r\n    return this as PostgrestBuilder<Record<string, unknown>>\r\n  }\r\n\r\n  /**\r\n   * Return `data` as the EXPLAIN plan for the query.\r\n   *\r\n   * @param options - Named parameters\r\n   *\r\n   * @param options.analyze - If `true`, the query will be executed and the\r\n   * actual run time will be returned\r\n   *\r\n   * @param options.verbose - If `true`, the query identifier will be returned\r\n   * and `data` will include the output columns of the query\r\n   *\r\n   * @param options.settings - If `true`, include information on configuration\r\n   * parameters that affect query planning\r\n   *\r\n   * @param options.buffers - If `true`, include information on buffer usage\r\n   *\r\n   * @param options.wal - If `true`, include information on WAL record generation\r\n   *\r\n   * @param options.format - The format of the output, can be `\"text\"` (default)\r\n   * or `\"json\"`\r\n   */\r\n  explain({\r\n    analyze = false,\r\n    verbose = false,\r\n    settings = false,\r\n    buffers = false,\r\n    wal = false,\r\n    format = 'text',\r\n  }: {\r\n    analyze?: boolean\r\n    verbose?: boolean\r\n    settings?: boolean\r\n    buffers?: boolean\r\n    wal?: boolean\r\n    format?: 'json' | 'text'\r\n  } = {}): PostgrestBuilder<Record<string, unknown>[]> | PostgrestBuilder<string> {\r\n    const options = [\r\n      analyze ? 'analyze' : null,\r\n      verbose ? 'verbose' : null,\r\n      settings ? 'settings' : null,\r\n      buffers ? 'buffers' : null,\r\n      wal ? 'wal' : null,\r\n    ]\r\n      .filter(Boolean)\r\n      .join('|')\r\n    // An Accept header can carry multiple media types but postgrest-js always sends one\r\n    const forMediatype = this.headers['Accept']\r\n    this.headers[\r\n      'Accept'\r\n    ] = `application/vnd.pgrst.plan+${format}; for=\"${forMediatype}\"; options=${options};`\r\n    if (format === 'json') return this as PostgrestBuilder<Record<string, unknown>[]>\r\n    else return this as PostgrestBuilder<string>\r\n  }\r\n\r\n  /**\r\n   * Rollback the query.\r\n   *\r\n   * `data` will still be returned, but the query is not committed.\r\n   */\r\n  rollback(): this {\r\n    if ((this.headers['Prefer'] ?? '').trim().length > 0) {\r\n      this.headers['Prefer'] += ',tx=rollback'\r\n    } else {\r\n      this.headers['Prefer'] = 'tx=rollback'\r\n    }\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Override the type of the returned `data`.\r\n   *\r\n   * @typeParam NewResult - The new result type to override with\r\n   */\r\n  returns<NewResult>(): PostgrestTransformBuilder<Schema, Row, NewResult, Relationships> {\r\n    return this as unknown as PostgrestTransformBuilder<Schema, Row, NewResult, Relationships>\r\n  }\r\n}\r\n", "import PostgrestTransformBuilder from './PostgrestTransformBuilder'\r\nimport { GenericSchema } from './types'\r\n\r\ntype FilterOperator =\r\n  | 'eq'\r\n  | 'neq'\r\n  | 'gt'\r\n  | 'gte'\r\n  | 'lt'\r\n  | 'lte'\r\n  | 'like'\r\n  | 'ilike'\r\n  | 'is'\r\n  | 'in'\r\n  | 'cs'\r\n  | 'cd'\r\n  | 'sl'\r\n  | 'sr'\r\n  | 'nxl'\r\n  | 'nxr'\r\n  | 'adj'\r\n  | 'ov'\r\n  | 'fts'\r\n  | 'plfts'\r\n  | 'phfts'\r\n  | 'wfts'\r\n\r\nexport default class PostgrestFilterBuilder<\r\n  Schema extends GenericSchema,\r\n  Row extends Record<string, unknown>,\r\n  Result,\r\n  Relationships = unknown\r\n> extends PostgrestTransformBuilder<Schema, Row, Result, Relationships> {\r\n  eq<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\r\n  eq(column: string, value: unknown): this\r\n  /**\r\n   * Match only rows where `column` is equal to `value`.\r\n   *\r\n   * To check if the value of `column` is NULL, you should use `.is()` instead.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\r\n  eq(column: string, value: unknown): this {\r\n    this.url.searchParams.append(column, `eq.${value}`)\r\n    return this\r\n  }\r\n\r\n  neq<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\r\n  neq(column: string, value: unknown): this\r\n  /**\r\n   * Match only rows where `column` is not equal to `value`.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\r\n  neq(column: string, value: unknown): this {\r\n    this.url.searchParams.append(column, `neq.${value}`)\r\n    return this\r\n  }\r\n\r\n  gt<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\r\n  gt(column: string, value: unknown): this\r\n  /**\r\n   * Match only rows where `column` is greater than `value`.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\r\n  gt(column: string, value: unknown): this {\r\n    this.url.searchParams.append(column, `gt.${value}`)\r\n    return this\r\n  }\r\n\r\n  gte<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\r\n  gte(column: string, value: unknown): this\r\n  /**\r\n   * Match only rows where `column` is greater than or equal to `value`.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\r\n  gte(column: string, value: unknown): this {\r\n    this.url.searchParams.append(column, `gte.${value}`)\r\n    return this\r\n  }\r\n\r\n  lt<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\r\n  lt(column: string, value: unknown): this\r\n  /**\r\n   * Match only rows where `column` is less than `value`.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\r\n  lt(column: string, value: unknown): this {\r\n    this.url.searchParams.append(column, `lt.${value}`)\r\n    return this\r\n  }\r\n\r\n  lte<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\r\n  lte(column: string, value: unknown): this\r\n  /**\r\n   * Match only rows where `column` is less than or equal to `value`.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\r\n  lte(column: string, value: unknown): this {\r\n    this.url.searchParams.append(column, `lte.${value}`)\r\n    return this\r\n  }\r\n\r\n  like<ColumnName extends string & keyof Row>(column: ColumnName, pattern: string): this\r\n  like(column: string, pattern: string): this\r\n  /**\r\n   * Match only rows where `column` matches `pattern` case-sensitively.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param pattern - The pattern to match with\r\n   */\r\n  like(column: string, pattern: string): this {\r\n    this.url.searchParams.append(column, `like.${pattern}`)\r\n    return this\r\n  }\r\n\r\n  likeAllOf<ColumnName extends string & keyof Row>(column: ColumnName, patterns: string[]): this\r\n  likeAllOf(column: string, patterns: string[]): this\r\n  /**\r\n   * Match only rows where `column` matches all of `patterns` case-sensitively.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param patterns - The patterns to match with\r\n   */\r\n  likeAllOf(column: string, patterns: string[]): this {\r\n    this.url.searchParams.append(column, `like(all).{${patterns.join(',')}}`)\r\n    return this\r\n  }\r\n\r\n  likeAnyOf<ColumnName extends string & keyof Row>(column: ColumnName, patterns: string[]): this\r\n  likeAnyOf(column: string, patterns: string[]): this\r\n  /**\r\n   * Match only rows where `column` matches any of `patterns` case-sensitively.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param patterns - The patterns to match with\r\n   */\r\n  likeAnyOf(column: string, patterns: string[]): this {\r\n    this.url.searchParams.append(column, `like(any).{${patterns.join(',')}}`)\r\n    return this\r\n  }\r\n\r\n  ilike<ColumnName extends string & keyof Row>(column: ColumnName, pattern: string): this\r\n  ilike(column: string, pattern: string): this\r\n  /**\r\n   * Match only rows where `column` matches `pattern` case-insensitively.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param pattern - The pattern to match with\r\n   */\r\n  ilike(column: string, pattern: string): this {\r\n    this.url.searchParams.append(column, `ilike.${pattern}`)\r\n    return this\r\n  }\r\n\r\n  ilikeAllOf<ColumnName extends string & keyof Row>(column: ColumnName, patterns: string[]): this\r\n  ilikeAllOf(column: string, patterns: string[]): this\r\n  /**\r\n   * Match only rows where `column` matches all of `patterns` case-insensitively.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param patterns - The patterns to match with\r\n   */\r\n  ilikeAllOf(column: string, patterns: string[]): this {\r\n    this.url.searchParams.append(column, `ilike(all).{${patterns.join(',')}}`)\r\n    return this\r\n  }\r\n\r\n  ilikeAnyOf<ColumnName extends string & keyof Row>(column: ColumnName, patterns: string[]): this\r\n  ilikeAnyOf(column: string, patterns: string[]): this\r\n  /**\r\n   * Match only rows where `column` matches any of `patterns` case-insensitively.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param patterns - The patterns to match with\r\n   */\r\n  ilikeAnyOf(column: string, patterns: string[]): this {\r\n    this.url.searchParams.append(column, `ilike(any).{${patterns.join(',')}}`)\r\n    return this\r\n  }\r\n\r\n  is<ColumnName extends string & keyof Row>(\r\n    column: ColumnName,\r\n    value: Row[ColumnName] & (boolean | null)\r\n  ): this\r\n  is(column: string, value: boolean | null): this\r\n  /**\r\n   * Match only rows where `column` IS `value`.\r\n   *\r\n   * For non-boolean columns, this is only relevant for checking if the value of\r\n   * `column` is NULL by setting `value` to `null`.\r\n   *\r\n   * For boolean columns, you can also set `value` to `true` or `false` and it\r\n   * will behave the same way as `.eq()`.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param value - The value to filter with\r\n   */\r\n  is(column: string, value: boolean | null): this {\r\n    this.url.searchParams.append(column, `is.${value}`)\r\n    return this\r\n  }\r\n\r\n  in<ColumnName extends string & keyof Row>(column: ColumnName, values: Row[ColumnName][]): this\r\n  in(column: string, values: unknown[]): this\r\n  /**\r\n   * Match only rows where `column` is included in the `values` array.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param values - The values array to filter with\r\n   */\r\n  in(column: string, values: unknown[]): this {\r\n    const cleanedValues = values\r\n      .map((s) => {\r\n        // handle postgrest reserved characters\r\n        // https://postgrest.org/en/v7.0.0/api.html#reserved-characters\r\n        if (typeof s === 'string' && new RegExp('[,()]').test(s)) return `\"${s}\"`\r\n        else return `${s}`\r\n      })\r\n      .join(',')\r\n    this.url.searchParams.append(column, `in.(${cleanedValues})`)\r\n    return this\r\n  }\r\n\r\n  contains<ColumnName extends string & keyof Row>(\r\n    column: ColumnName,\r\n    value: string | Row[ColumnName][] | Record<string, unknown>\r\n  ): this\r\n  contains(column: string, value: string | unknown[] | Record<string, unknown>): this\r\n  /**\r\n   * Only relevant for jsonb, array, and range columns. Match only rows where\r\n   * `column` contains every element appearing in `value`.\r\n   *\r\n   * @param column - The jsonb, array, or range column to filter on\r\n   * @param value - The jsonb, array, or range value to filter with\r\n   */\r\n  contains(column: string, value: string | unknown[] | Record<string, unknown>): this {\r\n    if (typeof value === 'string') {\r\n      // range types can be inclusive '[', ']' or exclusive '(', ')' so just\r\n      // keep it simple and accept a string\r\n      this.url.searchParams.append(column, `cs.${value}`)\r\n    } else if (Array.isArray(value)) {\r\n      // array\r\n      this.url.searchParams.append(column, `cs.{${value.join(',')}}`)\r\n    } else {\r\n      // json\r\n      this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`)\r\n    }\r\n    return this\r\n  }\r\n\r\n  containedBy<ColumnName extends string & keyof Row>(\r\n    column: ColumnName,\r\n    value: string | Row[ColumnName][] | Record<string, unknown>\r\n  ): this\r\n  containedBy(column: string, value: string | unknown[] | Record<string, unknown>): this\r\n  /**\r\n   * Only relevant for jsonb, array, and range columns. Match only rows where\r\n   * every element appearing in `column` is contained by `value`.\r\n   *\r\n   * @param column - The jsonb, array, or range column to filter on\r\n   * @param value - The jsonb, array, or range value to filter with\r\n   */\r\n  containedBy(column: string, value: string | unknown[] | Record<string, unknown>): this {\r\n    if (typeof value === 'string') {\r\n      // range\r\n      this.url.searchParams.append(column, `cd.${value}`)\r\n    } else if (Array.isArray(value)) {\r\n      // array\r\n      this.url.searchParams.append(column, `cd.{${value.join(',')}}`)\r\n    } else {\r\n      // json\r\n      this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`)\r\n    }\r\n    return this\r\n  }\r\n\r\n  rangeGt<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\r\n  rangeGt(column: string, range: string): this\r\n  /**\r\n   * Only relevant for range columns. Match only rows where every element in\r\n   * `column` is greater than any element in `range`.\r\n   *\r\n   * @param column - The range column to filter on\r\n   * @param range - The range to filter with\r\n   */\r\n  rangeGt(column: string, range: string): this {\r\n    this.url.searchParams.append(column, `sr.${range}`)\r\n    return this\r\n  }\r\n\r\n  rangeGte<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\r\n  rangeGte(column: string, range: string): this\r\n  /**\r\n   * Only relevant for range columns. Match only rows where every element in\r\n   * `column` is either contained in `range` or greater than any element in\r\n   * `range`.\r\n   *\r\n   * @param column - The range column to filter on\r\n   * @param range - The range to filter with\r\n   */\r\n  rangeGte(column: string, range: string): this {\r\n    this.url.searchParams.append(column, `nxl.${range}`)\r\n    return this\r\n  }\r\n\r\n  rangeLt<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\r\n  rangeLt(column: string, range: string): this\r\n  /**\r\n   * Only relevant for range columns. Match only rows where every element in\r\n   * `column` is less than any element in `range`.\r\n   *\r\n   * @param column - The range column to filter on\r\n   * @param range - The range to filter with\r\n   */\r\n  rangeLt(column: string, range: string): this {\r\n    this.url.searchParams.append(column, `sl.${range}`)\r\n    return this\r\n  }\r\n\r\n  rangeLte<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\r\n  rangeLte(column: string, range: string): this\r\n  /**\r\n   * Only relevant for range columns. Match only rows where every element in\r\n   * `column` is either contained in `range` or less than any element in\r\n   * `range`.\r\n   *\r\n   * @param column - The range column to filter on\r\n   * @param range - The range to filter with\r\n   */\r\n  rangeLte(column: string, range: string): this {\r\n    this.url.searchParams.append(column, `nxr.${range}`)\r\n    return this\r\n  }\r\n\r\n  rangeAdjacent<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\r\n  rangeAdjacent(column: string, range: string): this\r\n  /**\r\n   * Only relevant for range columns. Match only rows where `column` is\r\n   * mutually exclusive to `range` and there can be no element between the two\r\n   * ranges.\r\n   *\r\n   * @param column - The range column to filter on\r\n   * @param range - The range to filter with\r\n   */\r\n  rangeAdjacent(column: string, range: string): this {\r\n    this.url.searchParams.append(column, `adj.${range}`)\r\n    return this\r\n  }\r\n\r\n  overlaps<ColumnName extends string & keyof Row>(\r\n    column: ColumnName,\r\n    value: string | Row[ColumnName][]\r\n  ): this\r\n  overlaps(column: string, value: string | unknown[]): this\r\n  /**\r\n   * Only relevant for array and range columns. Match only rows where\r\n   * `column` and `value` have an element in common.\r\n   *\r\n   * @param column - The array or range column to filter on\r\n   * @param value - The array or range value to filter with\r\n   */\r\n  overlaps(column: string, value: string | unknown[]): this {\r\n    if (typeof value === 'string') {\r\n      // range\r\n      this.url.searchParams.append(column, `ov.${value}`)\r\n    } else {\r\n      // array\r\n      this.url.searchParams.append(column, `ov.{${value.join(',')}}`)\r\n    }\r\n    return this\r\n  }\r\n\r\n  textSearch<ColumnName extends string & keyof Row>(\r\n    column: ColumnName,\r\n    query: string,\r\n    options?: { config?: string; type?: 'plain' | 'phrase' | 'websearch' }\r\n  ): this\r\n  textSearch(\r\n    column: string,\r\n    query: string,\r\n    options?: { config?: string; type?: 'plain' | 'phrase' | 'websearch' }\r\n  ): this\r\n  /**\r\n   * Only relevant for text and tsvector columns. Match only rows where\r\n   * `column` matches the query string in `query`.\r\n   *\r\n   * @param column - The text or tsvector column to filter on\r\n   * @param query - The query text to match with\r\n   * @param options - Named parameters\r\n   * @param options.config - The text search configuration to use\r\n   * @param options.type - Change how the `query` text is interpreted\r\n   */\r\n  textSearch(\r\n    column: string,\r\n    query: string,\r\n    { config, type }: { config?: string; type?: 'plain' | 'phrase' | 'websearch' } = {}\r\n  ): this {\r\n    let typePart = ''\r\n    if (type === 'plain') {\r\n      typePart = 'pl'\r\n    } else if (type === 'phrase') {\r\n      typePart = 'ph'\r\n    } else if (type === 'websearch') {\r\n      typePart = 'w'\r\n    }\r\n    const configPart = config === undefined ? '' : `(${config})`\r\n    this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`)\r\n    return this\r\n  }\r\n\r\n  match<ColumnName extends string & keyof Row>(query: Record<ColumnName, Row[ColumnName]>): this\r\n  match(query: Record<string, unknown>): this\r\n  /**\r\n   * Match only rows where each column in `query` keys is equal to its\r\n   * associated value. Shorthand for multiple `.eq()`s.\r\n   *\r\n   * @param query - The object to filter with, with column names as keys mapped\r\n   * to their filter values\r\n   */\r\n  match(query: Record<string, unknown>): this {\r\n    Object.entries(query).forEach(([column, value]) => {\r\n      this.url.searchParams.append(column, `eq.${value}`)\r\n    })\r\n    return this\r\n  }\r\n\r\n  not<ColumnName extends string & keyof Row>(\r\n    column: ColumnName,\r\n    operator: FilterOperator,\r\n    value: Row[ColumnName]\r\n  ): this\r\n  not(column: string, operator: string, value: unknown): this\r\n  /**\r\n   * Match only rows which doesn't satisfy the filter.\r\n   *\r\n   * Unlike most filters, `opearator` and `value` are used as-is and need to\r\n   * follow [PostgREST\r\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\r\n   * to make sure they are properly sanitized.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param operator - The operator to be negated to filter with, following\r\n   * PostgREST syntax\r\n   * @param value - The value to filter with, following PostgREST syntax\r\n   */\r\n  not(column: string, operator: string, value: unknown): this {\r\n    this.url.searchParams.append(column, `not.${operator}.${value}`)\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Match only rows which satisfy at least one of the filters.\r\n   *\r\n   * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST\r\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\r\n   * to make sure it's properly sanitized.\r\n   *\r\n   * It's currently not possible to do an `.or()` filter across multiple tables.\r\n   *\r\n   * @param filters - The filters to use, following PostgREST syntax\r\n   * @param foreignTable - Set this to filter on foreign tables instead of the\r\n   * current table\r\n   */\r\n  or(filters: string, { foreignTable }: { foreignTable?: string } = {}): this {\r\n    const key = foreignTable ? `${foreignTable}.or` : 'or'\r\n    this.url.searchParams.append(key, `(${filters})`)\r\n    return this\r\n  }\r\n\r\n  filter<ColumnName extends string & keyof Row>(\r\n    column: ColumnName,\r\n    operator: `${'' | 'not.'}${FilterOperator}`,\r\n    value: unknown\r\n  ): this\r\n  filter(column: string, operator: string, value: unknown): this\r\n  /**\r\n   * Match only rows which satisfy the filter. This is an escape hatch - you\r\n   * should use the specific filter methods wherever possible.\r\n   *\r\n   * Unlike most filters, `opearator` and `value` are used as-is and need to\r\n   * follow [PostgREST\r\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\r\n   * to make sure they are properly sanitized.\r\n   *\r\n   * @param column - The column to filter on\r\n   * @param operator - The operator to filter with, following PostgREST syntax\r\n   * @param value - The value to filter with, following PostgREST syntax\r\n   */\r\n  filter(column: string, operator: string, value: unknown): this {\r\n    this.url.searchParams.append(column, `${operator}.${value}`)\r\n    return this\r\n  }\r\n}\r\n", "import PostgrestBuilder from './PostgrestBuilder'\r\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder'\r\nimport { GetResult } from './select-query-parser'\r\nimport { Fetch, GenericSchema, GenericTable, GenericView } from './types'\r\n\r\nexport default class PostgrestQueryBuilder<\r\n  Schema extends GenericSchema,\r\n  Relation extends GenericTable | GenericView,\r\n  Relationships = Relation extends { Relationships: infer R } ? R : unknown\r\n> {\r\n  url: URL\r\n  headers: Record<string, string>\r\n  schema?: string\r\n  signal?: AbortSignal\r\n  fetch?: Fetch\r\n\r\n  constructor(\r\n    url: URL,\r\n    {\r\n      headers = {},\r\n      schema,\r\n      fetch,\r\n    }: {\r\n      headers?: Record<string, string>\r\n      schema?: string\r\n      fetch?: Fetch\r\n    }\r\n  ) {\r\n    this.url = url\r\n    this.headers = headers\r\n    this.schema = schema\r\n    this.fetch = fetch\r\n  }\r\n\r\n  /**\r\n   * Perform a SELECT query on the table or view.\r\n   *\r\n   * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`\r\n   *\r\n   * @param options - Named parameters\r\n   *\r\n   * @param options.head - When set to `true`, `data` will not be returned.\r\n   * Useful if you only need the count.\r\n   *\r\n   * @param options.count - Count algorithm to use to count rows in the table or view.\r\n   *\r\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\r\n   * hood.\r\n   *\r\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\r\n   * statistics under the hood.\r\n   *\r\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\r\n   * numbers.\r\n   */\r\n  select<\r\n    Query extends string = '*',\r\n    ResultOne = GetResult<Schema, Relation['Row'], Relationships, Query>\r\n  >(\r\n    columns?: Query,\r\n    {\r\n      head = false,\r\n      count,\r\n    }: {\r\n      head?: boolean\r\n      count?: 'exact' | 'planned' | 'estimated'\r\n    } = {}\r\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], ResultOne[], Relationships> {\r\n    const method = head ? 'HEAD' : 'GET'\r\n    // Remove whitespaces except when quoted\r\n    let quoted = false\r\n    const cleanedColumns = (columns ?? '*')\r\n      .split('')\r\n      .map((c) => {\r\n        if (/\\s/.test(c) && !quoted) {\r\n          return ''\r\n        }\r\n        if (c === '\"') {\r\n          quoted = !quoted\r\n        }\r\n        return c\r\n      })\r\n      .join('')\r\n    this.url.searchParams.set('select', cleanedColumns)\r\n    if (count) {\r\n      this.headers['Prefer'] = `count=${count}`\r\n    }\r\n\r\n    return new PostgrestFilterBuilder({\r\n      method,\r\n      url: this.url,\r\n      headers: this.headers,\r\n      schema: this.schema,\r\n      fetch: this.fetch,\r\n      allowEmpty: false,\r\n    } as unknown as PostgrestBuilder<ResultOne[]>)\r\n  }\r\n\r\n  /**\r\n   * Perform an INSERT into the table or view.\r\n   *\r\n   * By default, inserted rows are not returned. To return it, chain the call\r\n   * with `.select()`.\r\n   *\r\n   * @param values - The values to insert. Pass an object to insert a single row\r\n   * or an array to insert multiple rows.\r\n   *\r\n   * @param options - Named parameters\r\n   *\r\n   * @param options.count - Count algorithm to use to count inserted rows.\r\n   *\r\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\r\n   * hood.\r\n   *\r\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\r\n   * statistics under the hood.\r\n   *\r\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\r\n   * numbers.\r\n   *\r\n   * @param options.defaultToNull - Make missing fields default to `null`.\r\n   * Otherwise, use the default value for the column.\r\n   */\r\n  insert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\r\n    values: Row | Row[],\r\n    {\r\n      count,\r\n      defaultToNull = true,\r\n    }: {\r\n      count?: 'exact' | 'planned' | 'estimated'\r\n      defaultToNull?: boolean\r\n    } = {}\r\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null, Relationships> {\r\n    const method = 'POST'\r\n\r\n    const prefersHeaders = []\r\n    if (this.headers['Prefer']) {\r\n      prefersHeaders.push(this.headers['Prefer'])\r\n    }\r\n    if (count) {\r\n      prefersHeaders.push(`count=${count}`)\r\n    }\r\n    if (!defaultToNull) {\r\n      prefersHeaders.push('missing=default')\r\n    }\r\n    this.headers['Prefer'] = prefersHeaders.join(',')\r\n\r\n    if (Array.isArray(values)) {\r\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), [] as string[])\r\n      if (columns.length > 0) {\r\n        const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`)\r\n        this.url.searchParams.set('columns', uniqueColumns.join(','))\r\n      }\r\n    }\r\n\r\n    return new PostgrestFilterBuilder({\r\n      method,\r\n      url: this.url,\r\n      headers: this.headers,\r\n      schema: this.schema,\r\n      body: values,\r\n      fetch: this.fetch,\r\n      allowEmpty: false,\r\n    } as unknown as PostgrestBuilder<null>)\r\n  }\r\n\r\n  /**\r\n   * Perform an UPSERT on the table or view. Depending on the column(s) passed\r\n   * to `onConflict`, `.upsert()` allows you to perform the equivalent of\r\n   * `.insert()` if a row with the corresponding `onConflict` columns doesn't\r\n   * exist, or if it does exist, perform an alternative action depending on\r\n   * `ignoreDuplicates`.\r\n   *\r\n   * By default, upserted rows are not returned. To return it, chain the call\r\n   * with `.select()`.\r\n   *\r\n   * @param values - The values to upsert with. Pass an object to upsert a\r\n   * single row or an array to upsert multiple rows.\r\n   *\r\n   * @param options - Named parameters\r\n   *\r\n   * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how\r\n   * duplicate rows are determined. Two rows are duplicates if all the\r\n   * `onConflict` columns are equal.\r\n   *\r\n   * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If\r\n   * `false`, duplicate rows are merged with existing rows.\r\n   *\r\n   * @param options.count - Count algorithm to use to count upserted rows.\r\n   *\r\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\r\n   * hood.\r\n   *\r\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\r\n   * statistics under the hood.\r\n   *\r\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\r\n   * numbers.\r\n   *\r\n   * @param options.defaultToNull - Make missing fields default to `null`.\r\n   * Otherwise, use the default value for the column. This only applies when\r\n   * inserting new rows, not when merging with existing rows under\r\n   * `ignoreDuplicates: false`.\r\n   */\r\n  upsert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\r\n    values: Row | Row[],\r\n    {\r\n      onConflict,\r\n      ignoreDuplicates = false,\r\n      count,\r\n      defaultToNull = true,\r\n    }: {\r\n      onConflict?: string\r\n      ignoreDuplicates?: boolean\r\n      count?: 'exact' | 'planned' | 'estimated'\r\n      defaultToNull?: boolean\r\n    } = {}\r\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null, Relationships> {\r\n    const method = 'POST'\r\n\r\n    const prefersHeaders = [`resolution=${ignoreDuplicates ? 'ignore' : 'merge'}-duplicates`]\r\n\r\n    if (onConflict !== undefined) this.url.searchParams.set('on_conflict', onConflict)\r\n    if (this.headers['Prefer']) {\r\n      prefersHeaders.push(this.headers['Prefer'])\r\n    }\r\n    if (count) {\r\n      prefersHeaders.push(`count=${count}`)\r\n    }\r\n    if (!defaultToNull) {\r\n      prefersHeaders.push('missing=default')\r\n    }\r\n    this.headers['Prefer'] = prefersHeaders.join(',')\r\n\r\n    if (Array.isArray(values)) {\r\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), [] as string[])\r\n      if (columns.length > 0) {\r\n        const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`)\r\n        this.url.searchParams.set('columns', uniqueColumns.join(','))\r\n      }\r\n    }\r\n\r\n    return new PostgrestFilterBuilder({\r\n      method,\r\n      url: this.url,\r\n      headers: this.headers,\r\n      schema: this.schema,\r\n      body: values,\r\n      fetch: this.fetch,\r\n      allowEmpty: false,\r\n    } as unknown as PostgrestBuilder<null>)\r\n  }\r\n\r\n  /**\r\n   * Perform an UPDATE on the table or view.\r\n   *\r\n   * By default, updated rows are not returned. To return it, chain the call\r\n   * with `.select()` after filters.\r\n   *\r\n   * @param values - The values to update with\r\n   *\r\n   * @param options - Named parameters\r\n   *\r\n   * @param options.count - Count algorithm to use to count updated rows.\r\n   *\r\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\r\n   * hood.\r\n   *\r\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\r\n   * statistics under the hood.\r\n   *\r\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\r\n   * numbers.\r\n   */\r\n  update<Row extends Relation extends { Update: unknown } ? Relation['Update'] : never>(\r\n    values: Row,\r\n    {\r\n      count,\r\n    }: {\r\n      count?: 'exact' | 'planned' | 'estimated'\r\n    } = {}\r\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null, Relationships> {\r\n    const method = 'PATCH'\r\n    const prefersHeaders = []\r\n    if (this.headers['Prefer']) {\r\n      prefersHeaders.push(this.headers['Prefer'])\r\n    }\r\n    if (count) {\r\n      prefersHeaders.push(`count=${count}`)\r\n    }\r\n    this.headers['Prefer'] = prefersHeaders.join(',')\r\n\r\n    return new PostgrestFilterBuilder({\r\n      method,\r\n      url: this.url,\r\n      headers: this.headers,\r\n      schema: this.schema,\r\n      body: values,\r\n      fetch: this.fetch,\r\n      allowEmpty: false,\r\n    } as unknown as PostgrestBuilder<null>)\r\n  }\r\n\r\n  /**\r\n   * Perform a DELETE on the table or view.\r\n   *\r\n   * By default, deleted rows are not returned. To return it, chain the call\r\n   * with `.select()` after filters.\r\n   *\r\n   * @param options - Named parameters\r\n   *\r\n   * @param options.count - Count algorithm to use to count deleted rows.\r\n   *\r\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\r\n   * hood.\r\n   *\r\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\r\n   * statistics under the hood.\r\n   *\r\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\r\n   * numbers.\r\n   */\r\n  delete({\r\n    count,\r\n  }: {\r\n    count?: 'exact' | 'planned' | 'estimated'\r\n  } = {}): PostgrestFilterBuilder<Schema, Relation['Row'], null, Relationships> {\r\n    const method = 'DELETE'\r\n    const prefersHeaders = []\r\n    if (count) {\r\n      prefersHeaders.push(`count=${count}`)\r\n    }\r\n    if (this.headers['Prefer']) {\r\n      prefersHeaders.unshift(this.headers['Prefer'])\r\n    }\r\n    this.headers['Prefer'] = prefersHeaders.join(',')\r\n\r\n    return new PostgrestFilterBuilder({\r\n      method,\r\n      url: this.url,\r\n      headers: this.headers,\r\n      schema: this.schema,\r\n      fetch: this.fetch,\r\n      allowEmpty: false,\r\n    } as unknown as PostgrestBuilder<null>)\r\n  }\r\n}\r\n", "export const version = '1.7.1'\r\n", "import { version } from './version'\r\nexport const DEFAULT_HEADERS = { 'X-Client-Info': `postgrest-js/${version}` }\r\n", "import PostgrestQueryBuilder from './PostgrestQueryBuilder'\r\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder'\r\nimport PostgrestBuilder from './PostgrestBuilder'\r\nimport { DEFAULT_HEADERS } from './constants'\r\nimport { Fetch, GenericSchema } from './types'\r\n\r\n/**\r\n * PostgREST client.\r\n *\r\n * @typeParam Database - Types for the schema from the [type\r\n * generator](https://supabase.com/docs/reference/javascript/next/typescript-support)\r\n *\r\n * @typeParam SchemaName - Postgres schema to switch to. Must be a string\r\n * literal, the same one passed to the constructor. If the schema is not\r\n * `\"public\"`, this must be supplied manually.\r\n */\r\nexport default class PostgrestClient<\r\n  Database = any,\r\n  SchemaName extends string & keyof Database = 'public' extends keyof Database\r\n    ? 'public'\r\n    : string & keyof Database,\r\n  Schema extends GenericSchema = Database[SchemaName] extends GenericSchema\r\n    ? Database[SchemaName]\r\n    : any\r\n> {\r\n  url: string\r\n  headers: Record<string, string>\r\n  schema?: SchemaName\r\n  fetch?: Fetch\r\n\r\n  // TODO: Add back shouldThrowOnError once we figure out the typings\r\n  /**\r\n   * Creates a PostgREST client.\r\n   *\r\n   * @param url - URL of the PostgREST endpoint\r\n   * @param options - Named parameters\r\n   * @param options.headers - Custom headers\r\n   * @param options.schema - Postgres schema to switch to\r\n   * @param options.fetch - Custom fetch\r\n   */\r\n  constructor(\r\n    url: string,\r\n    {\r\n      headers = {},\r\n      schema,\r\n      fetch,\r\n    }: {\r\n      headers?: Record<string, string>\r\n      schema?: SchemaName\r\n      fetch?: Fetch\r\n    } = {}\r\n  ) {\r\n    this.url = url\r\n    this.headers = { ...DEFAULT_HEADERS, ...headers }\r\n    this.schema = schema\r\n    this.fetch = fetch\r\n  }\r\n\r\n  from<\r\n    TableName extends string & keyof Schema['Tables'],\r\n    Table extends Schema['Tables'][TableName]\r\n  >(relation: TableName): PostgrestQueryBuilder<Schema, Table>\r\n  from<ViewName extends string & keyof Schema['Views'], View extends Schema['Views'][ViewName]>(\r\n    relation: ViewName\r\n  ): PostgrestQueryBuilder<Schema, View>\r\n  from(relation: string): PostgrestQueryBuilder<Schema, any>\r\n  /**\r\n   * Perform a query on a table or a view.\r\n   *\r\n   * @param relation - The table or view name to query\r\n   */\r\n  from(relation: string): PostgrestQueryBuilder<Schema, any> {\r\n    const url = new URL(`${this.url}/${relation}`)\r\n    return new PostgrestQueryBuilder<Schema, any>(url, {\r\n      headers: { ...this.headers },\r\n      schema: this.schema,\r\n      fetch: this.fetch,\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Perform a function call.\r\n   *\r\n   * @param fn - The function name to call\r\n   * @param args - The arguments to pass to the function call\r\n   * @param options - Named parameters\r\n   * @param options.head - When set to `true`, `data` will not be returned.\r\n   * Useful if you only need the count.\r\n   * @param options.count - Count algorithm to use to count rows returned by the\r\n   * function. Only applicable for [set-returning\r\n   * functions](https://www.postgresql.org/docs/current/functions-srf.html).\r\n   *\r\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\r\n   * hood.\r\n   *\r\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\r\n   * statistics under the hood.\r\n   *\r\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\r\n   * numbers.\r\n   */\r\n  rpc<\r\n    FunctionName extends string & keyof Schema['Functions'],\r\n    Function_ extends Schema['Functions'][FunctionName]\r\n  >(\r\n    fn: FunctionName,\r\n    args: Function_['Args'] = {},\r\n    {\r\n      head = false,\r\n      count,\r\n    }: {\r\n      head?: boolean\r\n      count?: 'exact' | 'planned' | 'estimated'\r\n    } = {}\r\n  ): PostgrestFilterBuilder<\r\n    Schema,\r\n    Function_['Returns'] extends any[]\r\n      ? Function_['Returns'][number] extends Record<string, unknown>\r\n        ? Function_['Returns'][number]\r\n        : never\r\n      : never,\r\n    Function_['Returns']\r\n  > {\r\n    let method: 'HEAD' | 'POST'\r\n    const url = new URL(`${this.url}/rpc/${fn}`)\r\n    let body: unknown | undefined\r\n    if (head) {\r\n      method = 'HEAD'\r\n      Object.entries(args).forEach(([name, value]) => {\r\n        url.searchParams.append(name, `${value}`)\r\n      })\r\n    } else {\r\n      method = 'POST'\r\n      body = args\r\n    }\r\n\r\n    const headers = { ...this.headers }\r\n    if (count) {\r\n      headers['Prefer'] = `count=${count}`\r\n    }\r\n\r\n    return new PostgrestFilterBuilder({\r\n      method,\r\n      url,\r\n      headers,\r\n      schema: this.schema,\r\n      body,\r\n      fetch: this.fetch,\r\n      allowEmpty: false,\r\n    } as unknown as PostgrestBuilder<Function_['Returns']>)\r\n  }\r\n}\r\n"],
  "mappings": "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",
  "names": ["crossFetch", "res", "fetch", "fetch"]
}
